{
  "guides/assetbundles.html": {
    "href": "guides/assetbundles.html",
    "title": "Asset Bundles Guide",
    "summary": "Asset Bundles Guide This guide will show you how to convert and package custom files into the Asset Bundle format, which can easily be loaded by your mods. You will learn how to take a file exported from a 3D modeling program (such as Blender) and turn it into a GameObject which can then be loaded by your mod. Basic modding knowledge is required for this tutorial. Here are some things you will need to know: Basic modding and C# knowledge Basic knowledge of how to navigate the Unity game engine interface The first thing you will need to do (Assuming you have a model already) is download the Unity Hub. This is where you will get the Unity version you need to use to export your asset bundle. The version Subnautica uses is 2019.4.36. This is the same on Below Zero. Here are the download links you will need: Unity hub: https://unity.com/download Unity version archive: https://unity.com/releases/editor/archive Creating the Unity Project Note It's not necessary to make a new Unity project for each mod (individual projects are actually quite large), but for this tutorial we will be making a fresh project. Once you've installed both, open Unity hub and click \"New Project\" from the top right. Next, follow these steps: Verify your Unity version is correct. Select 3D core from the template list. Configure your project name and location. Click on \"Create Project.\" Note If you get the error \" Failed to resolve project template \", follow these steps: Locate where your editor is. You can do that by opening Unity Hub, going to Installs, and then right clicking on the version in question and clicking \"Show in Explorer.\" Go to Editor\\Data\\Resources\\PackageManager\\ProjectTemplates. You will find two files, manifest.json and UnityLicense.json. Delete them both. Kill Unity Hub in your task manager and open it again. You should now be able to create your project! The Unity editor will now open. This may take a while. Installing the Asset Bundle Browser Once the editor has opened, click on Window at the top of the editor, and then click Package Manager. Click on the dropdown at the top left and select Unity Registry if not on it already. Search for \"Asset Bundle Browser\" and install it. Creating the Prefab Once the editor is open, drag your model from your file manager into the Scene window. You can either click on your model in the scene window or in the hierarchy on the left to select it. If you need to, you may place your model under an empty GameObject (in the editor, GameObject -> Create Empty) to apply any necessary model scaling and to separate it from any other children. Constructable prefabs (aka base modules) specifically REQUIRE the model object to be separate from the entire prefab as an individual child object. Next, drag your model from the hierarchy on the left into the Project section at the bottom. This will create what is called a Prefab. It can be instantiated (created/spawned) multiple times, but they are all copies of the original. Editing the Prefab and Adding Components To edit the prefab, double click on it in the Project window. You can add components to the prefab by clicking \"Add Component\" in the inspector on the right. One example of a component is a Rigidbody, which can apply physics to your Prefab. Keep in mind, however, that every (non-kinematic) Rigidbody requires a WorldForces component to work properly, which must be added either through code or with a tool such as Thunderkit. Any components you add will be included in the AssetBundle. Caution You should not , however, add scripts to your prefab that you made in the editor! The AssetBundle will not link them to the scripts in your modding project and you will get errors. Assigning the Asset Bundle Next, follow these steps to assign an asset bundle to your prefab. After all your prefab configuration is done, select it in the Project window. Click on \"Asset Bundle\" in the bottom right of the Inspector. Here you can either assign your prefab to an existing AssetBundle or create a new one. Exporting the Asset Bundle Once you've assigned your AssetBundle, open the Asset Bundle Browser (Window → AssetBundleBrowser at the top of the editor). Here you can see all the assets that will be put into your AssetBundle. Click on the build tab, and change the Build Target to \"Standalone Windows\" if it isn't already. You can also configure the Output Path of the build. After all that is set, click Build. Once your AssetBundle is built, move the built file to the location of your mod in the Plugins folder. It's generally prefered to put them inside a folder named \"Assets\", but that isn't necessary. Now the hard part is done! All you need to do is load it within your mod's code. Referencing the AssetBundleModule Warning If you are using the Nautilus template or have installed the Nautilus NuGet package, skip this step. The template and package include all the UnityEngine references already, so referencing them twice may cause errors. The first thing you will need to do is add the UnityEngine.AssetBundleModule.dll as a reference in your IDE (Assuming you don't already have it referenced). Visual Studio 2022 JetBrains Rider .NET CLI Open your project tab and right click on References. Select Add Reference. Click Browse, and navigate to [Game Location]/Subnautica_Data/Managed, and add UnityEngine.AssetBundleModule.dll as a reference. Click Ok to close the window. Right click on your project, and navigate to Add → Add Reference. Click Add From. Navigate to [Game Location]/Subnautica_Data/Managed, and add UnityEngine.AssetBundleModule.dll as a reference. Click Ok to close the window. Open a terminal. Enter dotnet add [Path to your project file (.csproj)] reference [Subnautica Location]/Subnautica_Data/Managed/UnityEngine.AssetBundleModule.dll. Using the Asset Bundle Note The way you load assets from the Asset Bundle will depend on if you're using Nautilus or not. Not using Nautilus Using Nautilus Here's some example code of how you can load in your prefab: using BepInEx; using System.IO; using System.Reflection; using UnityEngine; namespace Examples { internal class AssetBundles : BaseUnityPlugin { // Usually this is done in your Plugin script but technically you can do it wherever public static AssetBundle MyAssetBundle { get; private set; } // This gets the path to the \"Assets\" folder inside my plugin folder // If you don't have an assets folder you can replace \"AssetsFolderPath\" with Assembly.GetExecutingAssembly().Location // That just gets the path to the .dll of the mod public static string AssetsFolderPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), \"Assets\"); private void Awake() { // Keep in mind that the assetbundle can only be open in one place at a time, so keep a reference MyAssetBundle = AssetBundle.LoadFromFile(Path.Combine(AssetsFolderPath, \"myAssetBundle\")); // This name needs to be the exact same name as the prefab you put in the bundle GameObject mirrorVariant1 = AssetBundle.LoadAsset<GameObject>(\"myGameObject\"); } } } Here is one example of how to load in the asset bundle using the Nautilus AssetBundleLoadingUtils class: using BepInEx; using Nautilus.Utility; using System.IO; using System.Reflection; using UnityEngine; namespace Examples { internal class AssetBundles : BaseUnityPlugin { // Usually this is done in your Plugin script but technically you can do it wherever public static AssetBundle MyAssetBundle { get; private set; } private void Awake() { // Keep in mind that the assetbundle can only be open in one place at a time, so keep a reference // This method assumes you have a folder named \"Assets\" in your mod's plugin folder // The second parameter needs to be the name of the asset bundle file (Usually they don't have file extensions) MyAssetBundle = AssetBundleLoadingUtils.LoadFromAssetsFolder(Assembly.GetExecutingAssembly(), \"myAssetBundle\") // This name needs to be the exact same name as the prefab you put in the bundle GameObject mirrorVariant1 = MyAssetBundle.LoadAsset<GameObject>(\"myGameObject\"); } } } Using the Imported Asset And just like that you have your prefab in your code! To use a GameObject from your Asset Bundle in a Nautilus prefab, simply write myCustomPrefab.SetGameObject(myAssetBundleGO); Instead of using a prefab template. For more complicated prefabs (such as buildables), you can create your own method that loads the prefab from the asset bundle and applies extensive modifications to it. You can also apply changes to the prefab directly. E.g., myAssetBundleGO.AddComponent<WorldForces>(); Here is one example of how to use an Asset Bundle GameObject in a custom prefab: using Nautilus.Assets; using Nautilus.Assets.Gadgets; using Nautilus.Crafting; using Nautilus.Utility; using UnityEngine; using Ingredient = CraftData.Ingredient; namespace ExamplePrefab { internal static class MyCoolPrefab { public static PrefabInfo MyPrefabInfo { get; private set; } public static void Patch() { PrefabInfo prefabInfo = PrefabInfo.WithTechType(\"MyCoolPrefab\", \"My Cool Prefab\", \"Pretty cool, right!\") .WithIcon(SpriteManager.Get(TechType.Titanium)); // Just using the Titanium sprite as a placeholder // Cache the tech type for use in other places MyPrefabInfo = prefabInfo; var prefab = new CustomPrefab(prefabInfo); // Create the recipe RecipeData recipe = new RecipeData { craftAmount = 1, Ingredients = { new Ingredient(TechType.Titanium, 2), new Ingredient(TechType.CopperWire, 2), }, }; // Set the prefab GamrObject to the result of the GetAssetBundlePrefab method prefab.SetGameObject(GetAssetBundlePrefab()); // Using the Seaglide as a placeholder unlock prefab.SetUnlock(TechType.Seaglide); // Set the recipe prefab.SetRecipe(recipe) .WithCraftingTime(6f); // Add the prefab to the Miscellaneous tab of the blueprints in the PDA prefab.SetPdaGroupCategory(TechGroup.Miscellaneous, TechCategory.Misc); // Register the prefab to the Nautilus prefab database prefab.Register(); } private static GameObject GetAssetBundlePrefab() { GameObject myCoolPrefab = assetBundle.LoadAsset<GameObject>(\"myCoolPrefab\"); // The classID is the same as the one we put into the PrefabInfo.WithTechType up above // The LargeWorldEntity.CellLevel determines how far away the object will be loaded from the player PrefabUtils.AddBasicComponents(myCoolPrefab, MyPrefabInfo.ClassID, MyPrefabInfo.TechType, LargeWorldEntity.CellLevel.Medium); // Makes the GameObject have the correct shaders // You can use the optional inputs here to change the look of your object MaterialUtils.ApplySNShaders(myCoolPrefab); // Allows the object to be picked up myCoolPrefab.AddComponent<Pickupable>(); // Return the GameObject with all the components added return myCoolPrefab; } } } There are endless possibilities with Asset Bundles, so don't hesitate to experiment! If you have more questions about Asset Bundles, feel free to ask in the modding channels of the modding Discord."
  },
  "guides/debugging.html": {
    "href": "guides/debugging.html",
    "title": "Setting up Debugging",
    "summary": "Setting up Debugging This guide will show you how to enable advanced tools to make it easier to diagnose errors in your mods. You should at least be somewhat familiar with modding for this tutorial. It is assumed that you have a development environment set up with both a Debug and a Release configuration, know basic C#, and have developed your first mod. Note The contents of this guide are not specific to Subnautica and will work for any Unity game as long as a version of BepInEx that uses Unity Doorstop 4 is installed (v5.4.23.2+). Features and Limitations Using debug information generated during build, you can: Get exact line numbers in exceptions that show up in the log file. Attach a debugger to the game. Use standard debugging features like breakpoints, executing code one line at a time, and watching what's happening in your variables. However, you cannot: Use the above features for code for which you do not have a .pdb file, i.e. any code you did not write yourself. In particular, you cannot use this to debug code that is part of Subnautica. Generating Debug Symbols The first step is to make your IDE generate debugging information while it builds your mod. We will do this only for the Debug configuration, so that you can use Debug for your own testing and Release for sharing your finished mod with others. Depending on your IDE the settings will be located in different places. Visual Studio JetBrains Rider In the file explorer window on the left, right-click on your project and choose Properties... At the top of this new popup window, select the Debug configuration from the dropdown. On the left, navigate to the Build submenu. Set the Debug Symbols dropdown to Portable. In the file explorer window on the left, right-click on your project and choose Properties... Navigate to the Debug configuration. Tick Debug Symbols and set the debug type to Portable. Your IDE now generates a {projectname}.pdb file on every build. This file contains all the debug information about your project. Place this file next to your mod's .dll in the BepInEx/plugins directory so that debugging tools can read it. It is important that whenever you build a new version of your mod you also remember to update the .pdb file. Otherwise, the debug information will not line up with your actual code and the debugger will get confused. Tip To ensure your files are always in sync, use MSBuild's post-build actions to automatically deploy both the .dll and the .pdb to your game folder. Enabling the Debugging Server Since version 5.4.23.2, BepInEx ships with Unity Doorstop 4, which provides a built-in debugging server. Navigate to your Subnautica install directory (the same place as Subnautica.exe), where you should find a file called doorstop_config.ini. If you do not have this file, ensure you have the correct version of BepInEx installed. In doorstop_config.ini, do the following: Set debug_enabled to true. Take note of the address in debug_address for later. Optionally, set debug_suspend to true. This will force the game to freeze until you attach a debugger. This is useful if you need to debug code that executes very early on, before the game even loads into the main menu. If unsure, leave this off. With the debugging server enabled and the information from your .pdb files in the right place, any exceptions that happen in your mod will now display the correct line numbers, regardless of whether a debugger is attached. Connecting a Debugger to the Debugging Server Visual Studio JetBrains Rider Using Visual Studio's built-in Debugger Visual Studio does not provide support for Unity out of the box. We first need to make sure you have the correct plugin installed to enable Unity debugging. Follow the instructions on Microsoft's help page to install the Game Development with Unity workload. You do not need to install Unity itself or the Unity Hub, just the VS workload is enough. To make sure you won't have to repeat the following steps every time you want to debug, ensure that in the options menu found via the menu bar under Tools > Options > Tools for Unity > General the setting Use saved debug targets is set to true. In the menu bar at the top of the screen, select Debug > Attach Unity Debugger. In the new window that pops up, click Input IP. Enter the address you noted down earlier from the doorstep config. By default, the hostname will be 127.0.0.1 and the port 10000. Save the connection. From now on, you can debug your mod at any time by choosing your saved connection from the Attach to Unity Player button with the green play symbol in the top right of your IDE. Note that you must start Subnautica first and then connect the debugger second. Start setting breakpoints, explore your code in real time, and see what your variables are really doing. Learn more about Visual Studio's debugger and what it can do in the official docs. Warning Debugging with Rider on Windows can show NullReferenceExceptions in the variable debugging view for types which are defined in UnityEngine.CoreModule (notably MonoBehaviours!). Sometimes you can still see the contents of every variable of a supposedly \"null\" MonoBehaviour and set breakpoints as usual, but in our testing this has been inconsistent. This issue was not encountered on Linux, which makes us think it's a problem with Rider itself. As of Rider v2025.1.2, the Windows version still has this issue. Using Rider's built-in Debugger At the top right of your screen next to the green debug icon, click on the More Actions dropdown (indicated by three vertical dots) and Attach to Unity Process... If these dots are not there for you, you can also find this option in the menu bar under Run > Attach to Unity Process... Click Add Player Address Manually. Give the connection a name and fill in the address you noted down earlier from the doorstop config. By default, the hostname will be 127.0.0.1 and the port 10000. Save the connection. From now on, you can choose your debugging connection and press the green bug icon to start the debugger and connect to Subnautica at any time. Note that you must start Subnautica first and then connect the debugger second. Start setting breakpoints, explore your code in real time, and see what your variables are really doing. Learn more about Rider's debugger and what it can do in their docs."
  },
  "guides/dev-setup.html": {
    "href": "guides/dev-setup.html",
    "title": "Development Setup Guide",
    "summary": "Development Setup Guide This article covers a step-by-step guide of setting up your pc for Subnautica mod development. Please note that this setup works on any operating system, so if you're using a non-windows machine, don't worry! You're in the right place! Note Although we try to keep this guide as comprehensible as possible, we will not cover a C# tutorial. So a basic understanding of the language is still required. .NET Academy covers the basics in a simple interactable tutorial. If you need a more in-depth C# tutorial, the Giraffe Academy video is a good start. To start developing, you will need to install some tools first: Latest .NET SDK An integrated development environment (IDE) BepInEx 5.4.21 Nautilus .NET SDK .NET software development kit (SDK) is the main component of starting to write C# code. The SDK will take care of compiling our code, as well as enable the latest C# version features. In Nautilus we always make sure to update to the latest C# versions. To enable numerous inspection warnings and convenience while working with Nautilus, we recommend you to update the .NET SDK to the latest version. Tip Microsoft usually schedules their .NET Core releases around November every year. To install .NET SDK: Head to the .NET download page Select the latest recommended .NET SDK Download and run the installer. A restart may be needed to take place afterward. To ensure that the SDK has installed correctly, open a terminal and run the following line: dotnet --version Output: 7.0.102 Picking an IDE The top 3 IDEs for writing C# code are the following: Visual Studio Community - Free, great IDE designed for .NET development (Windows and Mac only) JetBrains Rider - Paid, outstanding IDE, incredible code-completion and code suggestions with the power of ReSharper, cross-platform Visual Studio Code - Free, multi-purpose editor, cross-platform, can be used for C# development with plugins. Installing IDE Visual Studio Community JetBrains Rider Visual Studio Code Download the installer from the Visual Studio download page and run it Inside the Visual Studio installer, ensure the .NET Desktop Development component is selected, then proceed with the installation. Download the installer from the JetBrains Rider download page Run the installer and follow the wizard steps. Download the installer from the VS Code download page and run it Install the .NET extension pack. This pack includes these extensions: C# for Visual Studio Code Ionide for F# Jupyter Notebooks Polyglot Notebooks You can also install extensions separately. Installing BepInEx BepInEx is a mod loader that we use to load Subnautica mods to the game. We recommend using the Subnautica BepInEx Pack as it's configured specifically for the game. The installation process is explained in the provided link. Installing Nautilus Download Nautilus from one of Nexus Mods, Submodica or GitHub Releases. Drop and drop the plugins folder in the zip file to: PathToSubnautica\\BepInEx\\ Installing Subnautica Modding templates Since the project setup can be quite tedious for experienced developers and confusing for new-comers, we have published a series of templates to help you setup your projects more easily. To install the template, run the following command in a terminal: dotnet new install Subnautica.Templates Note If you receive an error about not having any defined/enabled NuGet sources, you may need to run the following command first: dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org Once the install is completed, you will receive an output similar to the message below displaying the process as successful. Template Name Short Name Language Tags ---------------------------------------- -------------- -------- --------------------------------------------- Subnautica Empty Template snmod_empty [C#] SNModding/Subnautica/Mod Subnautica Nautilus Template snmod_nautilus [C#] SNModding/Subnautica/Mod/Nautilus Subnautica Template snmod [C#] SNModding/Subnautica/Mod Subnautica: Below Zero Empty Template bzmod_empty [C#] SNModding/Subnautica: Below Zero/Mod Subnautica: Below Zero Nautilus Template bzmod_nautilus [C#] SNModding/Subnautica: Below Zero/Mod/Nautilus Subnautica: Below Zero Template bzmod [C#] SNModding/Subnautica: Below Zero/Mod Below is a description of what each of these templates represent: Template Name Short Name (ID) Description Subnautica Template snmod Contains all the essential configurations, dependencies, and a basic Plugin.cs with the Logger and harmony patcher. Subnautica Empty Template snmod_empty Contains all the essential configurations and dependencies with no additional files. Subnautica Nautilus Template snmod_nautilus Contains all the essential configurations, dependencies with Nautilus installed and a simple example demonstrating the usage of Nautilus. The Subnautica: Below Zero templates contain the exact same configurations as their corresponding Subnautica versions, except they install BZ dependencies instead. Creating a new mod project Once you installed the templates, they will appear among other templates in the \"Create new project\" section of your favorite IDE. You can also create the project using CLI: Subnautica Subnautica: Below Zero dotnet new snmod -n MyBeautifulMod Now you can add more code to the project, then build and put the compiled dll in Subnautica/BepInEx/plugins/. dotnet new bzmod -n MyBeautifulMod Now you can add more code to the project, then build and put the compiled dll in SubnauticaZero/BepInEx/plugins/. Note If you are using an empty template, please ensure that in your entry point class (the class that has a [BepInPlugin] attribute, usually called Plugin.cs) Nautilus is marked as a dependency if you use it. To add the dependency, simply add the [BepInDependency(\"com.snmodding.nautilus\")] attribute at the top of your entry point class. You may find an example here. For more information, visit the BepInEx docs."
  },
  "guides/overview.html": {
    "href": "guides/overview.html",
    "title": "Guides",
    "summary": "Guides Development Setup Guide Simple Mod Guide Updating from SML 2.0 to Nautilus Using External Assets (Asset Bundles) Setting up Debugging"
  },
  "guides/simple-mod.html": {
    "href": "guides/simple-mod.html",
    "title": "Simple Mod Guide",
    "summary": "Simple Mod Guide In this guide we will make a new knife using Nautilus that knock-backs enemies on-hit. Additionally, we will also create a new mineral and add it to our knife's recipe. Firstly, we will need to setup a development environment. If you haven't already, check out our Development setup guide. Now that we have a development environment, we can create a project using the Subnautica Templates. Visual Studio 2022 JetBrains Rider .NET CLI Open Visual Studio Click on \"Create new project\" Search for \"Nautilus\", click on \"Subnautica Nautilus Template\" or \"Subnautica: Below Zero Nautilus Template\" depending on the game you're trying to mod then hit next Choose a name for your project, then create the project Open JetBrains Rider Click on \"New solution\" At the left section choose \"Subnautica Nautilus Template\" or \"Subnautica: Below Zero Nautilus Template\" depending on the game you're trying to mod Pick a name for your project, then create the project Open a terminal Create a folder for where your project will be stored mkdir YourProjectName Navigate to the new folder using cd YourProjectName Create the project Subnautica: dotnet new snmod_nautilus Subnautica Below Zero: dotnet new bzmod_nautilus The new project should contain the following structure: MyAwesomeMod/Items/Equipment/YeetKnifePrefab.cs MyAwesomeMod/Plugin.cs Note It is recommended that you change the GUID of your mod. It will be automatically set to something like MyAwesomeMod, but for the sake of consistency it should look more like com.author.myawesomemod. To do this, you must open up your project's csproj file (Right Click -> Edit Project File). Once it's open, add this tag to the uppermost property group: <BepInExPluginGuid>com.author.modname</BepInExPluginGuid> and modify that to fit your mod. Note Please ensure that in your entry point class (the class that has a [BepInPlugin] attribute, usually called Plugin.cs) Nautilus is marked as a dependency if you use it. To add the dependency, simply add the [BepInDependency(\"com.snmodding.nautilus\")] attribute at the top of your entry point class. You may find an example here. For more information, visit the BepInEx docs. This template contains the code of a functional knife that knock-backs enemies on strike. This knife can be found in the Modification station. Now that we have the code for the knife, we will make our new custom mineral. Begin by creating a new directory under MyAwesomeMod/Items/ and name it Minerals. Create a new C# file by right clicking on the Minerals folder and call it Coal.cs. The project structure now should look like this: Our Coal mineral will be using the same model as the Nickel Ore. The Coal.cs file should end up looking something like this: public class Coal { // To access the TechType anywhere in the project public static PrefabInfo Info { get; private set; } public static void Register() { Info = PrefabInfo.WithTechType(\"Coal\", \"Coal\", \"Coal that makes me go yes.\"); var coalPrefab = new CustomPrefab(Info); // The model of our coal will use the same one as Nickel's. var coalObj = new CloneTemplate(Info, TechType.Nickel); coalPrefab.SetGameObject(coalObj); // register the coal to the game coalPrefab.Register(); } } Now we need to register this new Coal object into the game. To do that, open the Plugin.cs file and edit it to call the Coal.Register() method // Plugin.cs private void InitializePrefabs() { Coal.Register(); YeetKnifePrefab.Register(); } At this point, our Coal mineral is successfully added to the game. To add it as a recipe to our Yeet Knife, all we'll need to do is to edit the SetRecipe method of the YeetKnifePrefab object. // YeetKnifePrefab.cs ... public static void Register() { var customPrefab = new CustomPrefab(Info); var yeetKnifeObj = new CloneTemplate(Info, TechType.HeatBlade); yeetKnifeObj.ModifyPrefab += obj => { var heatBlade = obj.GetComponent<HeatBlade>(); var yeetKnife = obj.AddComponent<YeetKnife>().CopyComponent(heatBlade); Object.DestroyImmediate(heatBlade); yeetKnife.damage *= 2f; }; customPrefab.SetGameObject(yeetKnifeObj); // Recipe requires 1 Heat blade and 4 Coal. var recipe = new RecipeData(new Ingredient(TechType.HeatBlade), new Ingredient(Coal.Info.TechType, 4)); customPrefab.SetRecipe(recipe) .WithFabricatorType(CraftTree.Type.Workbench); customPrefab.SetEquipment(EquipmentType.Hand); customPrefab.Register(); } Now we can build the project, then put the compiled .dll file into Subnautica/BepInEx/plugins/ and launch the game to run our mod. As can be seen, the Coal does not have an icon and uses the default \"?\" sprite. To set an icon, we can simply call the WithIcon method on our PrefabInfo object. // Coal.cs public static void Register() { // Uses the Nickel Ore icon for the Coal item. Info = PrefabInfo.WithTechType(\"Coal\", \"Coal\", \"Coal that makes me go yes.\").WithIcon(SpriteManager.Get(TechType.Nickel)); var coalPrefab = new CustomPrefab(Info); // The model of our coal will use the same one as Nickel's. var coalObj = new CloneTemplate(Info, TechType.Nickel); coalPrefab.SetGameObject(coalObj); // register the coal to the game coalPrefab.Register(); } You can also set the icon to a .png file by using the ImageUtils class. This reaches the end of this guide. Please check out our Tutorials section to learn more about this library. For more examples, check out our Example mod."
  },
  "guides/sml2-to-nautilus.html": {
    "href": "guides/sml2-to-nautilus.html",
    "title": "Updating to Nautilus",
    "summary": "Updating to Nautilus In this article, we will be talking about the necessary changes you must apply to update your mod to Nautilus from SMLHelper 2.0. Namespace The root namespace for Nautilus is not the same as SMLHelper 2.0. - <RootNamespace>SMLHelper.V2</RootNamespace> + <RootNamespace>Nautilus</RootNamespace> Referencing In BepInEx, we no longer use a mod.json file to determine dependencies. Instead, this is done via the [BepInDependency] attribute. You can mark Nautilus as a dependency to your mod by simply adding the [BepInDependency(\"com.snmodding.nautilus\")] attribute at the top of your entry point class. Example For more information on the new development setup, please visit our Development Setup Guide. Handlers Handlers no longer implement an interface matching their name. Additionally, they're now public static. This means they also no longer have a public static Main property anymore, so you will have to drop it from anywhere mentioned in your code. Handler.cs Following the handler interfaces change, the overly under-used Handler class will leave us in Nautilus // Handler.cs - namespace SMLHelper.V2 - { - using Interfaces; - - /// <summary> - /// A simple location where every SMLHelper handler class can be accessed. - /// </summary> - public static class Handler - { - public static IBioReactorHandler BioReactorHandler => Handlers.BioReactorHandler.Main; - - public static ICraftDataHandler CraftDataHandler => Handlers.CraftDataHandler.Main; - - public static ICraftTreeHandler CraftTreeHandler => Handlers.CraftTreeHandler.Main; - - public static IIngameMenuHandler IngameMenuHandler => Handlers.IngameMenuHandler.Main; - ... - } BioReactorHandler The BioReactorHandler class is removed in Nautilus because it only had one very simple method to patch, and was forcing patch-time. That means if you tried to modify a bio charge after SML's entry point, it didn't get applied. The following example demonstrates how you can implement the same functionality the BioReactorHandler class offered. - BioReactorHandler.SetBioreactorCharge(TechType.Peeper, 69f); + BaseBioReactor.charge[TechType.Peeper] = 69f; FishHandler Ever since this class has been added, it never received any further updates due to unpopularity among modders, and unfamiliarity with how creatures worked in general and thus, has been broken for a long time. The FishHandler has been removed in Nautilus. At the time being, we have not added a system to replace it, so stay tuned for that. PDAEncyclopediaHandler And PDALogHandler Beginning with Nautilus, both of these handler methods were moved to PDAHandler as they only had one method each. PDAEncyclopedia.EntryData entry = new PDAEncyclopedia.EntryData() { key = \"SomeEncy\", path = \"Tech/Tools\", nodes = new[] { \"Tech\", \"Tools\" } }; - PDAEncyclopediaHandler.AddCustomEntry(entry); + PDAHandler.AddEncyclopediaEntry(entry); - PDALogHandler.AddCustomEntry(\"SomeLog\", \"SomeLanguageKey\"); + PDAHandler.AddLogEntry(\"SomeLog\", \"SomeLanguageKey\"); InGameMenuHandler The methods InGameMenuHandler class had have been moved to the Nautilus.Utility namespace and the class has been renamed to SaveUtils. - InGameMenuHandler.RegisterOnSaveEvent(() => ErrorMessage.AddMessage(\"We do be saving!\")); + SaveUtils.RegisterOnSaveEvent(() => ErrorMessage.AddMessage(\"We do be saving!\")); Enum Handlers Beginning with Nautilus, enum handling will be made generic. Instead of working with individual handlers associated with the enum type (E.G: For TechType we had TechTypeHandler), Now you can add a new enum value to any enum type by using EnumHandler.AddEntry<TEnum>(string enumName). This means the following handlers are removed: TechTypeHandler BackgroundTypeHandler EquipmentHandler PingTypeHandler TechCategoryHandler TechGroupHandler CraftTreeTypeHandler - Only the methods below are removed: CreateCustomCraftTreeAndType ModdedCraftTreeTypeExists The EnumHandler class contains the following methods, all of them can be used for any enum type: Signature Summary EnumBuilder<TEnum> AddEntry<TEnum>(string name) Adds a new enum value instance of TEnum type. bool ModdedEnumExists<TEnum>(string name) Safely looks for a custom enum object from another mod. bool TryGetValue<TEnum>(string name, out TEnum enumValue) Safely looks for a custom enum object from another mod and outputs the instance if found. Note The EnumHandler class only takes care of registering a new enum object for an enum type. Further configuration is now handled via extension methods for the EnumBuilder type. Below we will talk about the necessary changes you will need to make your custom enum values work for each of the aforementioned handlers. Configuring Custom TechType Objects - TechType customTech = TechTypeHandler.AddTechType(\"CustomTech\", \"Custom Tech\", \"Custom Tech that makes me go yes.\", SpriteManager.Get(TechType.Titanium), unlockedAtStart: false); + TechType customTech = EnumHandler.AddEntry<TechType>(\"CustomTech\") + .WithPdaInfo(\"Custom Tech\", \"Custom Tech that makes me go yes.\", unlockedAtStart: false) + .WithIcon(SpriteManager.Get(TechType.Titanium)); Configuring Custom CraftData.BackgroundType Objects - CraftData.BackgroundType customBG = BackgroundTypeHandler.AddBackgroundType(\"CustomBackground\", SpriteManager.GetBackground(TechType.Battery)); + CraftData.BackgroundType customBG = EnumHandler.AddEntry<CraftData.BackgroundType>(\"CustomBackground\") + .WithBackground(SpriteManager.GetBackground(TechType.Battery)); Configuring Custom EquipmentType Objects - EquipmentType customEquipment = EquipmentHandler.AddEquipmentType(\"CustomEquipment\"); + EquipmentType customEquipment = EnumHandler.AddEntry<EquipmentType>(\"CustomEquipment\"); Configuring Custom PingType Objects - PingType customPing = PingHandler.RegisterNewPingType(\"CustomPing\", SpriteManager.Get(SpriteManager.Group.Pings, PingType.Signal.ToString())); + PingType customPing = EnumHandler.AddEntry<PingType>(\"CustomPing\") + .WithIcon(SpriteManager.Get(SpriteManager.Group.Pings, PingType.Signal.ToString())); Configuring Custom TechCategory and TechGroup Objects - TechGroup customGroup = TechGroupHandler.AddTechCategory(\"CustomGroup\", \"Custom Group\"); + TechGroup customGroup = EnumHandler.AddEntry<TechCategory>(\"CustomGroup\").WithPdaInfo(\"Custom Group\"); - TechCategory customCategory = TechCategoryHandler.AddTechCategory(\"CustomCategory\", \"Custom Category\"); - TechCategoryHandler.TryRegisterTechCategoryToTechGroup(customGroup, customCategory); + TechCategory customCategory = EnumHandler.AddEntry<TechCategory>(\"CustomCategory\").WithPdaInfo(\"Custom Group\") + .RegisterToTechGroup(customGroup); Configuring Custom CraftTree.Type Objects - ModCraftTreeRoot root = CraftTreeHandler.CreateCustomCraftTreeAndType(CustomTree, out CraftTree.Type customTree); + CraftTree.Type customTree = EnumHandler.AddEntry<CraftTree.Type>(\"CustomTree\") + .CreateCraftTreeRoot(out ModCraftTreeRoot root); root.AddTabNode(\"SomeTab\"); Options The Options system backend was largely changed in Nautilus. This rewrite mostly effects the more in-depth options systems leaving the simplest usage(s) more or less untouched. Mods which made use of the ConfigFile attribute system should not require major changes. Mods which extended ModOptions to create their config system will require changes: All individual AddXYZOption methods have been replaced by a single unified generic AddItem method. This method takes a ModOption which can be created using ModXYZOption.Create(...). All individual Options_XXYZChanged methods have been replaced by a single unified OnChanged method. Option specific OnChanged events can be added to each option instead of being forced to use the global OnChange. ModChoiceOption has been made into a generic type ModChoiceOption<T> which can support an array of almost any type and enums. In addition to these Nautilus specific methods there have also been extensions provided to directly create Nautilus OptionItem instances from BepInEx ConfigEntry instances: var bepInExToggle = cfg.Bind<bool>( section: \"Testing boolean\", key: \"A boolean\", defaultValue: true ); AddItem(bepInExToggle.ToModToggleOption()); SML 2.0 public class ModOptionsV2 : ModOptions { public ModOptionsV2() : base(\"My Mod Options\") { OptionsPanelHandler.RegisterModOptions(this); SliderChanged += Options_SliderChanged; ChoiceChanged += Options_ChoiceChagned; } public override void BuildModOptions() { AddSliderOption(id: \"Foo\", label: \"Bar\", minValue: 0, maxValue: 100, value: 50); AddChoiceOption(id: \"Baz\", label: \"Qux\", options: new[] { \"ABC\", \"DEF\", \"XYZ\" }, index: 0); } private void Options_SliderChanged(object sender, SliderChangedEventArgs e) { switch (e.Id) { case \"Foo\": // Do stuff here break; } } private void Options_ChoiceChagned(object sender, ChoiceChangedEventArgs e) { switch (e.Id) { case \"Baz\": // Do stuff here break; } } } Nautilus public class ModOptionsV3 : ModOptions { public ModOptionsV3() : base(\"My Mod Options\") { OptionsPanelHandler.RegisterModOptions(this); OnChanged += GlobalOptions_Changed; var sliderWithChange = ModSliderOption.Create(id: \"Fancy\", label: \"Slider\", minValue: 0, maxValue: 100, value: 50); sliderWithChange.OnChanged += specific_OnChanged; AddItem(sliderWithChange); AddItem(ModSliderOption.Create(id: \"Foo\", label: \"Bar\", minValue: 0, maxValue: 100, value: 50)); AddItem(ModChoiceOption<string>.Create(id: \"Baz\", label: \"Qux\", options: new[] { \"ABC\", \"DEF\", \"XYZ\" }, index: 0)); } private void specific_OnChanged(object sender, SliderChangedEventArgs e) { // Do onChange here } private void GlobalOptions_Changed(object sender, OptionEventArgs e) { switch (e) { case SliderChangedEventArgs sliderArgs: switch (sliderArgs.Id) { case \"Foo\": // Do stuff here break; } break; case ChoiceChangedEventArgs<string> choiceArgs: switch (choiceArgs.Id) { case \"Baz\": // Do stuff here break; } break; } } } Assets The Assets system received a complete rewrite in Nautilus, making it the biggest change of this version. With this rewrite, asset classes are no longer an inherited chain mess, meaning Buildable, Craftable, CustomFabricator, Equipable, FishPrefab, PdaItem, Spawnable and ModPrefab classes have been removed. As of Nautilus, the asset system will have three main parts: Custom Prefabs, Gadgets, and Prefab Templates. The following table represents all the previous asset classes and what they have been replaced with in Nautilus. SML 2.0 (old) Nautilus (new) ModPrefab CustomPrefab Buildable, PdaItem ScanningGadget Equipable EquipmentGadget CustomFabricator FabricatorGadget Craftable CraftingGadget Spawnable ICustomPrefab.SetSpawns Custom Prefabs CustomPrefab is a class that takes care of registering gadgets and also the game object into the game. This class is essentially equivalent to the previous ModPrefab class. It is what you will use to actually make a custom prefab. Gadgets To put it simply, Gadgets are classes that take certain data and register them to the game for our custom prefab item. They are pretty much equivalent to the different asset classes and their properties we had before. Gadgets will be our primary way of interacting with game systems and to add functionality to a tech type and/or class ID. Note Gadgets only interact with tech types and/or class IDs. They don't have any business with a prefab's game object. Prefab Templates Previously on SML 2.0, asset classes optionally also provided game objects (E.G: CustomFabricator). To allow for diversity in the game object template you choose from and also to make it easier to manage such functionality and modularize game objects, we have moved game object templates to their own system: Prefab templates. Prefab templates will be our main way of providing a base game object for custom prefabs. There are a couple of options you can choose from that suit your needs, however, it is not enforced to choose one; you can still build up a game object from scratch. A couple of prefab templates that will be available in Nautilus are the following: CloneTemplate EnergySourceTemplate FabricatorTemplate Custom Prefab Examples In this example, we will demonstrate how you can change an SML 2.0 custom prefab to the Nautilus system. Equipable CustomFabricator SML 2.0 public class SeamothBrineResistanceModule : Equipable { public static TechType TechTypeID { get; protected set; } public SeamothBrineResistanceModule() : base(\"SeamothBrineResistModule\", \"Seamoth brine resistant coating\", \"Makes the Seamoth resistant to corrosive brine pools, by means of a protective coating.\") { OnFinishedPatching += () => { TechTypeID = this.TechType; }; } public override EquipmentType EquipmentType => EquipmentType.SeamothModule; public override TechType RequiredForUnlock => TechType.BaseUpgradeConsole; public override TechGroup GroupForPDA => TechGroup.VehicleUpgrades; public override TechCategory CategoryForPDA => TechCategory.VehicleUpgrades; public override CraftTree.Type FabricatorType => CraftTree.Type.SeamothUpgrades; public override string[] StepsToFabricatorTab => new string[] { \"SeamothModules\" }; public override QuickSlotType QuickSlotType => QuickSlotType.Passive; public override GameObject GetGameObject() { var prefab = CraftData.GetPrefabForTechType(TechType.SeamothElectricalDefense); var obj = GameObject.Instantiate(prefab); return obj; } protected override TechData GetBlueprintRecipe() { return new TechData() { craftAmount = 1, Ingredients = { new Ingredient(TechType.Polyaniline, 1), new Ingredient(TechType.CopperWire, 2), new Ingredient(TechType.AluminumOxide, 2), new Ingredient(TechType.Nickel, 1), }, }; } } Nautilus // Create a custom prefab instance and set the class ID, friendly name, and description respectively var seamothBrineResistanceModule = new CustomPrefab( \"SeamothBrineResistModule\", \"Seamoth brine resistant coating\", \"Makes the Seamoth resistant to corrosive brine pools, by means of a protective coating.\"); // Set our prefab to a clone of the Seamoth electrical defense module seamothBrineResistanceModule.SetGameObject(new CloneTemplate(seamothBrineResistanceModule.Info, TechType.SeamothElectricalDefense)); // Make our item compatible with the seamoth module slot seamothBrineResistanceModule.SetEquipment(EquipmentType.SeamothModule) .WithQuickSlotType(QuickSlotType.Passive); // Make the Vehicle upgrade console a requirement for our item's blueprint ScanningGadget scanning = seamothBrineResistanceModule.SetUnlock(TechType.BaseUpgradeConsole); // Add our item to the Vehicle upgrades category scanning.WithPdaGroupCategory(TechGroup.VehicleUpgrades, TechCategory.VehicleUpgrades); var recipe = new RecipeData() { craftAmount = 1, Ingredients = { new CraftData.Ingredient(TechType.Polyaniline, 1), new CraftData.Ingredient(TechType.CopperWire, 2), new CraftData.Ingredient(TechType.AluminumOxide, 2), new CraftData.Ingredient(TechType.Nickel, 1), }, }; // Add a recipe for our item, as well as add it to the Moonpool fabricator and Seamoth modules tab seamothBrineResistanceModule.SetRecipe(recipe) .WithFabricatorType(CraftTree.Type.SeamothUpgrades) .WithStepsToFabricatorTab(\"SeamothModules\"); // Register our item to the game seamothBrineResistanceModule.Register(); This example is based off of a real mod. You can get access to the full source code here. SML 2.0 public class AbyssFabricator : CustomFabricator { private static Texture2D texture; public override Models Model { get; } = Models.Fabricator; public AbyssFabricator() : base(\"AbyssFabricator\", \"Abyss Fabricator\", \"Abyss Batteries Fabricator\") { OnStartedPatching += () => { texture = ImageUtils.LoadTextureFromFile(Path.Combine(Main.AssetsFolder, \"AbyssFabricatorskin.png\")); }; } public override GameObject GetGameObject() { GameObject prefab = base.GetGameObject(); if (texture != null) { SkinnedMeshRenderer skinnedMeshRenderer = prefab.GetComponentInChildren<SkinnedMeshRenderer>(); skinnedMeshRenderer.material.mainTexture = texture; } return prefab; } protected override TechData GetBlueprintRecipe() { return new TechData { craftAmount = 1, Ingredients = new List<Ingredient> { new Ingredient(TechType.Titanium, 2), new Ingredient(TechType.Quartz, 2), new Ingredient(TechType.JeweledDiskPiece, 1), } }; } protected override Atlas.Sprite GetItemSprite() { return SpriteManager.Get(TechType.Fabricator); } public override TechCategory CategoryForPDA { get; } = TechCategory.InteriorModule; public override TechGroup GroupForPDA { get; } = TechGroup.InteriorModules; } Nautilus // Create a custom prefab instance and set the class ID, friendly name, description and icon respectively var abyssFabricator = new CustomPrefab( \"AbyssFabricator\", \"Abyss Fabricator\", \"Abyss Batteries Fabricator\", SpriteManager.Get(TechType.Fabricator)); // Create a custom crafting tree for this tech type. This method returns a FabricatorGadget, which we can use to customize our crafting tree. For example, to add a new tab or crafting node. var abyssFabCraftTree = abyssFabricator.CreateFabricator(out CraftTree.Type abyssFabType); // Load up the custom main (diffuse) texture from disk. var mainTexture = ImageUtils.LoadTextureFromFile(Path.Combine(AssetsFolder, \"AbyssFabricatorskin.png\")); // Create our fabricator game object. The fabricator game object will use the vanilla Fabricator model, then set the main texture to the texture we loaded earlier. var abyssFabricatorModel = new FabricatorTemplate(abyssFabricator.Info, abyssFabType) { FabricatorModel = FabricatorTemplate.Model.Fabricator, ModifyPrefab = obj => obj.GetComponentInChildren<SkinnedMeshRenderer>().material.mainTexture = mainTexture }; // Sets this prefab's game object to the model we created earlier. abyssFabricator.SetGameObject(abyssFabricatorModel); // Sets the recipe for the fabricator. abyssFabricator.SetRecipe(new RecipeData(new Ingredient(TechType.Titanium, 2), new Ingredient(TechType.Quartz, 2), new Ingredient(TechType.JeweledDiskPiece, 1))); // Adds the fabricator item to the Interior Modules group. This also makes our object buildable. abyssFabricator.SetPdaGroupCategory(TechGroup.InteriorModules, TechCategory.InteriorModule); // Register our item to the game. abyssFabricator.Register(); This example is based off of a real mod. You can get access to the full source code here. Audio and FMOD In the last few versions of SML 2, we made a lot of changes to the audio system SML offered, this was because of FMOD. FMOD is the sound engine Subnautica uses. It is more advanced and flexible compared to the built-in Unity audio system. Since we discovered the best practices and better ways to deal with custom sounds, we have deleted a bunch of previously-obsolete methods from CustomSoundHandler and AudioUtils classes, as well as the SoundChannel enumeration in Nautilus. Beginning with Nautilus, all custom sounds will require a bus instead of a SoundChannel to determine the effects (E.G: reverb, muffling, low-pass, etc..) and the volume slider. Additionally, the PlaySound signature was also modified and renamed to TryPlaySound. - Channel channel = AudioUtils.PlaySound(soundPath, SoundChannel.Music); + if (AudioUtils.TryPlaySound(soundPath, AudioUtils.BusPaths.Music, out Channel channel)) + { + // do something with channel + } - Channel channel = AudioUtils.PlaySound(soundPath, SoundChannel.Voice); + if (AudioUtils.TryPlaySound(soundPath, AudioUtils.BusPaths.PDAVoice, out Channel channel)) + { + // do something with channel + } - Channel channel = AudioUtils.PlaySound(soundPath, SoundChannel.Ambient); + if (AudioUtils.TryPlaySound(soundPath, AudioUtils.BusPaths.UnderwaterAmbient, out Channel channel)) + { + // do something with channel + } - Channel channel = AudioUtils.PlaySound(soundPath, SoundChannel.Master); + if (AudioUtils.TryPlaySound(soundPath, \"bus:/\", out Channel channel)) + { + // do something with channel + } Warning Creating or playing a custom sound on the master bus is il-advised as it is dangerous and has the possibility of breaking the audio for a game session. Try to set an appropriate bus for your sound instead of the master one."
  },
  "index.html": {
    "href": "index.html",
    "title": "Nautilus: Subnautica Modding Library",
    "summary": "Nautilus: Subnautica Modding Library Nautilus is a modding library that aims to enhance developer productivity by offering common helper utilities as easy to use and robust as possible. Notable systems which Nautilus offers include but not limited to: Adding/editing items, implementing custom sprites & textures, custom audio, Subnautica-style configuration menu, and so much more! ⚠️ Nautilus is only supported on the latest version of Subnautica and Below Zero. If you're playing on the Legacy branch of Steam, use SMLHelper instead. Contributing - Issues"
  },
  "tutorials/async-mod-loading.html": {
    "href": "tutorials/async-mod-loading.html",
    "title": "Mod loading during the loading screen",
    "summary": "Mod loading during the loading screen The more complex your project, the more loading and/or setup it is likely to have to do. It is common for mod authors to do all their initial loading in their plugin's Awake() method. On its own, this is not a problem. However, when a user installs many mods, all of which do all their loading at the very beginning, it can look like the game has crashed on a black screen before the main menu even loads. Imagine if, instead, all this loading happened at a time when the user knows that loading is going to happen, and can even see the current progress. Imagine if mods could do all their loading as part of the game's actual loading screen. Enter the WaitScreenTask. WaitScreenTasks can be used for many different things, but consider using them if: Your mod needs to load files (e.g. asset bundles, JSON files) Your mod needs to do a considerable amount of computing before the game loads Your mod requires something done before the game loads that it cannot function without (i.e. you are worried about race conditions) You want to make a quick adjustment moments before the game has finished loading Understanding WaitScreenTasks You should know: 1. The game must wait Nautilus inserts a few extra stages into the loading screen. During each of these stages, any registered WaitScreenTasks are completed one by one, each only proceeding when the previous one has finished. The game cannot exit the loading screen until every single task is done. 2. Registration order The tasks are always completed in the order they were registered. This allows you to set up chains of tasks that depend on the result of the previous one. For example, you could create one task that loads an asset bundle, and then a second task that uses said bundle to do something else, or register a SaveDataCache and then a second task which requires access to save data (see below). 3. Three Loading Stages During the loading screen, there are three stages you can register a task for: Early, Main, and Late. They differ only in their execution timing. The Early stage executes almost immediately after the player finishes pressing the button in the main menu and the loading screen appears. Crucially, the game is still technically in the main menu. Any GameObjects created during this stage will be destroyed during the scene transition to the main game. SaveDataCaches are loaded here. The Main stage executes after the scene has switched to the in-game Main scene. This is the ideal time to initialise custom GameObjects or perform any other work that doesn't require special timing. Note that even though the main scene has loaded, it is prevented from performing all its usual setup until this mod loading stage is finished. As a result, commonly used singletons like Player.main or EscapePod.main do not exist and none of the game's objects have had a chance to Awake() yet. The Late stage executes just before the loading screen would usually end. All vanilla GameObjects have run Awake() and finished their setup. Any tasks that run here can make last-minute changes to the game without worrying about the player gaining control before everything is ready. 4. SaveDataCache uses WaitScreenTask SaveDataCaches also use the WaitScreenTask system. Registering a cache with the SaveDataHandler implicitly registers a task during the Early mod loading stage which will load the cache. Any tasks registered after the cache can always rely on save data being ready for use. Simple example This code demonstrates how to register a simple task to make a last-second change to the game. The example increases the life pod's inventory size just before the game is ready to play. private void Awake() { ... // Other plugin setup code // First, register your task, for example during your plugin Awake(). // We choose the Late stage for this task because we need access to the life pod. WaitScreenHandler.RegisterLateLoadTask(\"ExampleMod\", ExpandPodInventory); } // This function will be called by Nautilus as part of the task during the loading screen. private void ExpandPodInventory(WaitScreenHandler.WaitScreenTask task) { // Change the life pod's inventory to be 10x10. EscapePod.main.storageContainer.Resize(10, 10); } Example using a SaveDataCache This example demonstrates how to use save data from a SaveDataCache in a task. public class ExampleSaveData : SaveDataCache { public bool ExampleThing; } public class ExampleMod : BaseUnityPlugin { private void Awake() { ... // Other plugin setup code // First, register your save data. var saveData = SaveDataHandler.RegisterSaveDataCache<ExampleSaveData>(); // Despite choosing the Early load stage for this task, we can always be sure that the save data is ready // because we registered the save data first. // Our function expects to be given ExampleSaveData, but Nautilus will always try to give it a WaitScreenTask. // Here, we use a lambda expression to discard the task and pass the save data instead. WaitScreenHandler.RegisterEarlyLoadTask(\"ExampleMod\", _ => DoSaveDependentThing(saveData)); } private void DoSaveDependentThing(ExampleSaveData saveData) { // Do something that is different from save to save. if (saveData.ExampleThing) { ... } } } If the above example confuses you, you may want to read up on C# lambda expressions. Reporting Status By default, while a task is executing Nautilus will simply show the task number and your mod's name. You can add more context for the player in one of two ways: Either by adding a decription while you register your task or by editing the status text during task execution. Adding a description The description will persist through the entire duration of the task. private void Awake() { ... // This is the same escape pod inventory example as above, but this time we add more context. WaitScreenHandler.RegisterLateLoadTask(\"ExampleMod\", ExpandPodInventory, \"Expanding Inventory!\"); } // Other code ... Updating status during a task You can set the status text directly through the WaitScreenTask argument you are given by Nautilus. Note that this only makes sense for longer tasks that take a long time to complete. Your task also must be an async task, otherwise the loading screen never gets to run the code that shows any changes you make to the status. private void Awake() { ... WaitScreenHandler.RegisterAsyncLoadTask(\"ExampleMod\", PerformSetupAsync); } private IEnumerator PerformSetupAsync(WaitScreenHandler.WaitScreenTask task) { // Set the new status. task.Status = \"Loading important assets...\"; // The loading screen will show the new status the next time you yield. yield return CoroutineThatLoadsAssetBundles(); // Set the status again to show the task has progressed. task.Status = \"Modifying game prefabs...\"; // This advances the game by one frame and lets the loading screen update. yield return null; // Run other code ... } You can also mix and match the two by adding a description during registration and then editing the status text later. File loading with WaitScreenTasks WaitScreenTasks force the loading screen to wait until they're complete, which makes them ideal for loading files. This way, you do not have to worry about whether the game is already way ahead of you by the time your mod has finally finished prep work. Nautilus ensures that it isn't. Loading AssetBundles A good way to go about loading asset bundles is to use an async task to simply wait until the bundle is loaded. This way, you avoid loading the bundle again on subsequent loads. private static AssetBundle _assetBundle; private void Awake() { ... WaitScreenHandler.RegisterAsyncLoadTask(\"ExampleMod\", LoadAssetsAsync); } private IEnumerator LoadAssetsAsync(WaitScreenHandler.WaitScreenTask task) { task.Status = \"Loading asset bundle...\"; // By caching the asset bundle we avoid loading it again later and speed up subsequent loads. if (_assetBundle == null) { // Load an asset bundle from the mod folder. request = AssetBundle.LoadFromFileAsync(\"exampleAssetBundle\"); // Wait until the bundle has finished loading. yield return request; // Cache the bundle for later. _assetBundle = request.assetBundle; } task.Status = \"Loading data from bundle...\"; // Load a GameObject for a custom plant from the asset bundle. var objRequest = _assetBundle.LoadAssetAsync<GameObject>(\"CustomPlant1\"); // Wait until the plant has finished loading. yield return objRequest; var gameObject = objRequest.asset as GameObject; // Do something with the GameObject ... } Loading non-bundle files You may need to load files that are not asset bundles for your mod to work properly. For example, mods which edit a lot of recipes often prefer to load their recipe changes from a JSON file rather than hardcoding it all. This can get a little more complicated because we need to convert from C# Async to Unity Coroutines. private void Awake() { ... // We use an async WaitScreenTask for file loading. WaitScreenHandler.RegisterAsyncLoadTask(\"ExampleMod\", LoadFileAsync); } // This method is a coroutine wrapped around the method that *actually* loads the file. private IEnumerator LoadFileAsync(WaitScreenHandler.WaitScreenTask task) { task.Status = \"Loading very important file...\"; // Start loading the file. Task<string> loadOperation = LoadImportantFileAsync(); // Wait until the file has finished loading. yield return new WaitUntil(() => loadOperation.IsCompleted); // Get the contents of the file. string contents = loadOperation.Result; // Do something with the file contents. ... } // This method is what actually loads the file. Unfortunately, Unity has poor async support // so it cannot be used directly. private async Task<string> LoadImportantFileAsync() { // Always open files with a 'using' statement so they don't stay opened indefinitely. using StreamReader reader = new StreamReader(File.OpenRead(\"recipeChanges.json\")); // Read everything and return it when done. string fileContents = await reader.ReadToEndAsync(); return fileContents; } Loading multiple files in one WaitScreenTask If you have multiple non-bundle files that each need loading you could follow the steps above for each one of these files individually, which would load one file, wait until it's done, then load the next, etc. Alternatively, you can start loading every file at once and simply wait until all of them have finished. // Define the filenames of each file that needs to be loaded. private string[] _fileNames = new[] { \"recipeChanges.json\", \"fragmentChanges.json\", \"databankChanges.json\" }; private void Awake() { ... // We use an async WaitScreenTask for file loading. WaitScreenHandler.RegisterAsyncLoadTask(\"ExampleMod\", LoadFilesAsync); } // This method is a coroutine wrapped around the method that *actually* loads the file. private IEnumerator LoadFilesAsync(WaitScreenHandler.WaitScreenTask task) { task.Status = \"Loading very important files...\"; // Keep a list of all active async Tasks. var fileTasks = new List<Task>(); // Start loading each file and keep track of its Task. foreach (string fileName of _fileNames) { fileTasks.Add(LoadImportantFileAsync(fileName)); } // Wait until all files have finished loading. yield return new WaitUntil(fileTasks.TrueForAll(fileTask => fileTask.IsCompleted)); // Do something with the file contents. ... } // This method is what actually loads the file. Unfortunately, Unity has poor async support // so it cannot be used directly. private async Task<string> LoadImportantFileAsync(string filePath) { // This time, we pass in the file path as an argument for reusability. using StreamReader reader = new StreamReader(File.OpenRead(filePath)); // Read everything and return it when done. string fileContents = await reader.ReadToEndAsync(); return fileContents; }"
  },
  "tutorials/audio.html": {
    "href": "tutorials/audio.html",
    "title": "FMOD and Custom Audio",
    "summary": "FMOD and Custom Audio This is a tutorial on adding custom sounds to Subnautica using FMOD. What is FMOD? FMOD is the proprietary sound engine used by Subnautica. The specific version used by Subnautica is FMOD for Unity, also known as FMODUnity. The developers of Subnautica used a program called FMOD Studio, software specifically designed to create sound events, buses, effects, etc. for use in games. Unfortunately, modders cannot utilize this until the game's metadata is released. Therefore, FMOD support for mods is relatively limited. However, many options still exist, as this guide will show. Can I Use Unity Audio? While Unity audio (AudioSources, AudioClips, etc.) does function in Subnautica thanks to the BepInEx pack, it has various issues: It is not affected by the volume slider. Any effects, such as muffling and reverb, are not supported. These sounds continue to play while the game is paused. A problematic setup can cause ear-piercing screeching sounds. There is a risk of it using the wrong sound device. Unity audio cannot directly be used in any of the game's sound systems. There is, however, no issue with converting an AudioClip to an FMOD Event. Important Concepts Sounds A Sound in FMOD is a struct which essentially points to byte data of an audio clip. Sounds also have a MODE, as explained below. Sounds are necessary to create events. To create a Sound, see AudioUtils.CreateSound and similar methods in the same class. In Nautilus, you can create a Sound from a Unity AudioClip (with an Asset Bundle) or a raw sound file. You cannot (or at least generally should not) directly play a Sound. Instead, register the sound as an Event. Events FMOD events are what the game actually recognizes, interacts with and executes to play audio. Events can contain one sound or multiple random sounds, are assigned a bus, and can have various effects added. Every FMOD Event has a path and an ID. In custom sounds these are interchangeable. The path/ID is required to play the sound. To directly register a sound (or multiple) as an event, use the methods in the CustomSoundHandler. FMODAssets This is a concept created by Unknown Worlds, rather than being a part of FMOD. An FMODAsset is a type of ScriptableObject that contains fields for the event's path and id. These are used by the vast majority of the game's sound systems. In most cases, the game's system only uses the path, but it's a good practice to set both values (though for custom sounds, the two are interchangeable). To quickly create an FMOD Asset, you can call AudioUtils.GetFmodAsset, store the result, and use it as needed. It is recommended that you cache this reference to prevent memory leaks. List of FMOD Events for SN1 List of FMOD Events for BZ Common ways to play FMOD Assets: Assigning it to the asset field on one of the following built-in components. These components do not typically play the event automatically. FMOD_CustomEmitter FMOD_CustomLoopingEmitter FMOD_StudioEventEmitter Using Utils.PlayFMODAsset(asset, position) Don't use the overload that doesn't take a position— this typically results in silence, regardless of mode. Do not confuse Utils with UWE.Utils. These are two different classes. Buses In FMOD, \"buses\" are used to organize sounds into categories, typically for volume control and special effects. For instance, most buses are affected by various aspects of the game, such as being inside a base or swimming underwater. This is how muffling effects are controlled. Every sound event must be assigned a valid bus. You can find a complete list of bus paths for SN1 here, and a list for BZ here. Modes FMOD sounds can have various 'modes' applied to them. At least some must be applied for any sound to work properly. This is especially important for the distinction between directional (3D) and non-directional (2D) audio. Recommended modes: For 3D sounds: AudioUtils.StandardSoundModes_3D: MODE._3D | MODE.ACCURATETIME | MODE._3D_LINEARSQUAREROLLOFF For 2D sounds: AudioUtils.StandardSoundModes_2D: MODE._2D | MODE.ACCURATETIME For music: AudioUtils.StandardSoundModes_Stream: MODE._2D | MODE.ACCURATETIME | MODE.CREATESTREAM (this is a complicated topic of optimization) The FModSoundBuilder The FModSoundBuilder is a helpful builder class that simplifies the registration of audio in mods. Step 1: Define the audio source The FModSoundBuilder requires a 'CustomSoundSource' to function properly. The two implementations of this in Nautilus that you can use are the AssetBundleSoundSource, which takes in a loaded AssetBundle (so that you load clips by their clip name), and the ModFolderSoundSource, which loads clips directly from a folder within your mod folder. Keep in mind that the folder should be devoid of any other unrelated files if you choose to use that option. Example 1 (AssetBundleSoundSource): // Load the asset bundle (keep in mind, you should cache the AssetBundle in an actual project, and never load one twice) AssetBundle bundle = AssetBundleLoadingUtils.LoadFromAssetsFolder(Assembly, \"assetbundlename\"); // Tell the system to load clips from the given asset bundle by their name CustomSoundSourceBase soundSource = new AssetBundleSoundSource(bundle); Example 2 (ModFolderSoundSource) // Tell the system to load clips from a folder called \"SoundsFolder\", which is directly inside your mod folder CustomSoundSourceBase soundSource = new ModFolderSoundSource(\"SoundsFolder\"); Step 2: Create the builder FModSoundBuilder builder = new FModSoundBuilder(soundSource); Step 3: Register events Warning Do not use any file extensions with the FModSoundBuilder class. Extensions should be excluded from any strings here. For example, it would be 'CreatureSound1', not 'CreatureSound1.mp3'. Call the builder's CreateNewEvent(id, bus) method, passing in the ID/event path you want to register, and an existing bus path. Now, use the returned value to set any settings as necessary using the fluent syntax setup. See IFModSoundBuilder for a list of possible functions. Be sure to always call the Register method on the builder when you are done with a sound. Examples: // Registers a generic underwater sound builder.CreateNewEvent(\"EpicExplosionSound\", Nautilus.Utility.AudioUtils.BusPaths.UnderwaterAmbient) .SetMode3D(3, 70) // Distance falloff starts at 3 meters, and it cannot be heard beyond 70 meters. .SetSound(\"ExplosionSound\") // This could load ExplosionSound.mp3, ExplosionSound.wav, or an AssetBundle clip with the name, depending on the source and setup. .Register(); // Never forget to register your audio. // Registers a 2D user interface sound builder.CreateNewEvent(\"NewButtonSound\", \"bus:/master/SFX_for_pause/PDA_pause/all/SFX\") .SetMode2D() .SetSounds(true, \"NewButtonSound1\", \"NewButtonSound2\") // This loads two sounds. The one that plays each time is random. .Register(); // Registers a creature sound builder.CreateNewEvent(\"NewCreatureSound\", \"bus:/master/SFX_for_pause/PDA_pause/all/SFX/creatures\") .SetMode3D(1, 20) // Distance falloff starts at 1 meter, and it cannot be heard beyond 20 meters. .SetSounds(true, s => s.StartsWith(\"CreatureSound\")) // Loads all files that start with \"CreatureSound\", such as \"CreatureSound1\", \"CreatureSound2\", etc. .Register(); // Registers custom music builder.CreateNewEvent(\"EpicBiomeMusic\", AudioUtils.BusPaths.Music) .SetModeMusic() // Sets the mode to be 2D and optimized for music. .SetFadeDuration(2) // The music will take 2 seconds to fade out if stopped while playing. .SetSounds(true, \"BiomeTrack1\", \"BiomeTrack2\", \"BiomeTrack3\") // The music will play one of these tracks at random. .Register(); If you wanted to, you could now play one of those sounds like this: Utils.PlayFMODAsset(Nautilus.Utility.AudioUtils.GetFmodAsset(\"NewCreatureSound\"), Player.main.transform.position);"
  },
  "tutorials/background-type.html": {
    "href": "tutorials/background-type.html",
    "title": "",
    "summary": "How does the game handle background colors for items? The game has a built-in enum called BackgroundType, which sits in the CraftData class. The possible values for this enum are listed below. public enum BackgroundType { Normal, Blueprint, PlantWater, PlantWaterSeed, PlantAir, PlantAirSeed, ExosuitArm } How can I create a custom background type? To create a new custom background type, you will need to register an image as the background for some BackgroundType instance. Fortunately, the custom enums system has made this step really simple. All you will have to do is name your brand new BackgroundType instance, then register an image for it. private void Awake() { var myCustomBackground = EnumHandler.AddEntry<CraftData.BackgroundType>(\"CustomBackground\") .WithBackground(ImageUtils.LoadSpriteFromFile(pathToImage)); } And that's it. Now you can use the new CraftData.BackgroundType instance anywhere you want. How can I change an item's background? To edit an item's background type, you need to call the CraftDataHandler.SetBackgroundType method sitting in the Nautilus.Handlers namespace Examples The following example demonstrates the usage of SetBackgroundType That makes the titanium background color green. CraftDataHandler.SetBackgroundType(TechType.Titanium, CraftData.BackgroundType.PlantAirSeed); Similarly, if we wanted to set the titanium's background to our custom background from earlier, it would look like the following: CraftDataHandler.SetBackgroundType(TechType.Titanium, myCustomBackground);"
  },
  "tutorials/biomes.html": {
    "href": "tutorials/biomes.html",
    "title": "Adding Custom Biomes",
    "summary": "Adding Custom Biomes This guide provides some information on adding custom biomes. Note This page is under construction and may not be finished any time soon. However, any information currently provided should still be accurate. SN1 Biome Settings: Biome name Sky name Settings safeShallows SkySafeShallows Absorption: (125.0, 20.0, 4.0) Scattering: 1.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1.5 Temperature: 28 safeShallows_WreckInterior SkyExplorableWreck Absorption: (125.0, 20.0, 4.0) Scattering: 0.6 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 28 kelpForest SkyKelpForest Absorption: (80.0, 25.0, 30.0) Scattering: 1.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.16 Emissive: RGBA(0.934, 1.000, 0.000, 1.000) Emissive scale: 0.01 Start distance: 25 Sunlight scale: 1 Ambient scale: 1.5 Temperature: 27 kelpForest_WreckInterior SkyExplorableWreck Absorption: (80.0, 25.0, 30.0) Scattering: 1.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.16 Emissive: RGBA(0.934, 1.000, 0.000, 1.000) Emissive scale: 0.01 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 27 grassyPlateaus SkyGrassyPlateaus Absorption: (10.0, 4.5, 3.0) Scattering: 0.4 Scattering color: RGBA(0.761, 0.761, 0.761, 1.000) Murkiness: 0.45 Emissive: RGBA(0.267, 0.498, 0.663, 1.000) Emissive scale: 0.06 Start distance: 35 Sunlight scale: 1.75 Ambient scale: 2 Temperature: 26 grassyPlateaus_WreckInterior SkyExplorableWreck Absorption: (20.0, 7.0, 3.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 26 mountains SkyMountains Absorption: (40.0, 15.0, 9.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.12 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1.4 Ambient scale: 1 Temperature: 24 mushroomForest SkyMushroomForest Absorption: (100.0, 30.0, 20.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.05 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1 Ambient scale: 2 Temperature: 24 kooshZone SkyKooshZone Absorption: (30.0, 23.0, 12.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.14 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 grandReef SkyGrandReef Absorption: (16.0, 12.0, 6.0) Scattering: 2 Scattering color: RGBA(0.000, 1.000, 0.912, 1.000) Murkiness: 0.25 Emissive: RGBA(0.000, 0.956, 1.000, 1.000) Emissive scale: 0.03 Start distance: 40 Sunlight scale: 0.5 Ambient scale: 20 Temperature: 24 deepGrandReef SkyDeepGrandReef Absorption: (6.0, 4.0, 3.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.000, 0.959, 1.000, 1.000) Emissive scale: 0.04 Start distance: 25 Sunlight scale: 0 Ambient scale: 100 Temperature: 24 ilzChamber SkyILZChamber Absorption: (0.1, 2.0, 2.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(0.451, 0.455, 0.271, 1.000) Emissive scale: 0.09 Start distance: 80 Sunlight scale: 0 Ambient scale: 0 Temperature: 60 ilzCorridor SkyILZChamber Absorption: (3.0, 3.0, 1.5) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.376, 0.439, 0.447, 1.000) Emissive scale: 0.035 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 60 sparseReef SkyMountains Absorption: (10.0, 2.8, 2.8) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.8 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 floatingIslandsSurface SkyMountains Absorption: (100.0, 18.3, 3.5) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 floatingIsland SkyMountains Absorption: (100.0, 18.3, 3.5) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(0.000, 0.216, 0.196, 1.000) Emissive scale: 10 Start distance: 25 Sunlight scale: 3.2 Ambient scale: 1 Temperature: 34 floatingIslandBelow SkyMountains Absorption: (3.0, 1.5, 1.0) Scattering: 0.7 Scattering color: RGBA(0.000, 0.408, 0.573, 1.000) Murkiness: 0.55 Emissive: RGBA(0.000, 0.490, 0.784, 1.000) Emissive scale: 0.03 Start distance: 10 Sunlight scale: 0.03 Ambient scale: 0.2 Temperature: 24 underwaterIslands SkyMountains Absorption: (25.0, 10.0, 5.0) Scattering: 0.8 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(1.000, 0.279, 0.629, 1.000) Emissive scale: 0.015 Start distance: 25 Sunlight scale: 1 Ambient scale: 5 Temperature: 24 underwaterIslands_IslandCave SkyMountains Absorption: (25.0, 10.0, 5.0) Scattering: 0.8 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.000, 0.250, 1.000, 1.000) Emissive scale: 0.15 Start distance: 15 Sunlight scale: 0 Ambient scale: 5 Temperature: 24 underwaterIslands_Cave SkyMountains Absorption: (25.0, 10.0, 5.0) Scattering: 0.8 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.368, 0.000, 1.000, 1.000) Emissive scale: 0.1 Start distance: 15 Sunlight scale: 0 Ambient scale: 5 Temperature: 24 dunes SkyDunes Absorption: (20.0, 10.0, 6.0) Scattering: 0.5 Scattering color: RGBA(0.341, 0.427, 0.447, 1.000) Murkiness: 0.2 Emissive: RGBA(0.102, 0.133, 0.149, 1.000) Emissive scale: 0.2 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 bloodKelp SkyBloodKelp Absorption: (50.0, 8.0, 4.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 crashZone SkyCrashZone Absorption: (20.0, 20.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.12 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 20 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 bloodKelp_Trench SkyBloodKelp Absorption: (35.0, 9.0, 5.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 1.000, 1.000, 1.000) Emissive scale: 0.005 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 bloodKelp_Cave SkyBloodKelp Absorption: (100.0, 33.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 safeShallows_Cave SkySafeShallows_Caves Absorption: (25.0, 15.0, 6.0) Scattering: 0.1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0.005 Start distance: 25 Sunlight scale: 0.02 Ambient scale: 1 Temperature: 26 safeShallows_HugeTube SkySafeShallows Absorption: (125.0, 20.0, 4.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.4 Ambient scale: 1 Temperature: 26 safeShallows_CaveEntrance SkySafeShallows Absorption: (125.0, 20.0, 4.0) Scattering: 1.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(0.956, 0.984, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.8 Ambient scale: 0.8 Temperature: 27 jellyshroomCaves SkyJellyshroomCaves Absorption: (3.0, 3.0, 3.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.570, 0.339, 0.853, 1.000) Emissive scale: 0.05 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 jellyshroomCaves_Entrance SkyJellyshroomCaves Absorption: (16.0, 6.0, 3.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(1.000, 0.000, 0.931, 1.000) Emissive scale: 0.01 Start distance: 25 Sunlight scale: 0.4 Ambient scale: 1 Temperature: 24 kelpForest_Dense SkyKelpForest Absorption: (140.0, 32.0, 47.0) Scattering: 1.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(0.934, 1.000, 0.000, 1.000) Emissive scale: 0.02 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 27 kelpForest_Cave SkyKelpForest Absorption: (140.0, 32.0, 47.0) Scattering: 0.1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.1 Ambient scale: 1 Temperature: 25 kelpForest_CaveEntrance SkyKelpForest Absorption: (80.0, 25.0, 30.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.4 Ambient scale: 1 Temperature: 26 bloodKelp_DeepTrench SkyBloodKelp Absorption: (35.0, 9.0, 5.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0.005 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 grassyPlateaus_Cave SkyGrassyPlateaus Absorption: (5.0, 6.0, 3.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.8 Emissive: RGBA(0.208, 0.353, 1.000, 1.000) Emissive scale: 0.03 Start distance: 20 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 kooshZone_cave_trans SkyKooshZone Absorption: (14.0, 10.0, 10.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0.01 Start distance: 25 Sunlight scale: 0.3 Ambient scale: 1 Temperature: 24 kooshZone_cave_dark SkyKooshZone Absorption: (14.0, 10.0, 10.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0.01 Start distance: 25 Sunlight scale: 0 Ambient scale: 0.2 Temperature: 24 Mountains_Cave SkyMountainsCaves Absorption: (40.0, 15.0, 9.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.1 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0.2 Temperature: 24 Mountains_Island_Cave SkyMountainsCaves Absorption: (40.0, 15.0, 9.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.1 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0.2 Temperature: 24 Mountains_IslandSurface_Cave SkyMountains Absorption: (40.0, 15.0, 9.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.1 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0.2 Temperature: 24 Mountains_CaveEntrance SkyMountains Absorption: (40.0, 15.0, 9.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.1 Ambient scale: 1 Temperature: 24 Mountains_Island_CaveEntrance SkyMountains Absorption: (40.0, 15.0, 9.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.1 Ambient scale: 1 Temperature: 24 Mountains_IslandSurface_CaveEntrance SkyMountains Absorption: (40.0, 15.0, 9.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 1 Temperature: 24 Dunes_Cave_light SkyMountains Absorption: (20.0, 10.0, 6.0) Scattering: 0.1 Scattering color: RGBA(0.341, 0.427, 0.447, 1.000) Murkiness: 0.2 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.8 Ambient scale: 1 Temperature: 24 Dunes_Cave_Dark SkyMountains Absorption: (20.0, 10.0, 6.0) Scattering: 0.1 Scattering color: RGBA(0.341, 0.427, 0.447, 1.000) Murkiness: 0.2 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.5 Ambient scale: 0.8 Temperature: 24 mushroomForest_cave_light SkyMushroomForest Absorption: (100.0, 30.0, 20.0) Scattering: 0.8 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.1 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.8 Ambient scale: 1 Temperature: 24 mushroomForest_cave_dark SkyMushroomForestCave Absorption: (100.0, 30.0, 20.0) Scattering: 0.1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(0.000, 0.824, 1.000, 1.000) Emissive scale: 0.075 Start distance: 25 Sunlight scale: 0 Ambient scale: 1 Temperature: 24 PrecursorCave_MushroomForest SkyMushroomForestCave Absorption: (0.2, 0.2, 0.2) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1.5 Emissive: RGBA(0.000, 0.824, 1.000, 1.000) Emissive scale: 0.002 Start distance: 10 Sunlight scale: 0 Ambient scale: 1 Temperature: 24 GrandReef_Cave SkyGrandReef Absorption: (12.0, 10.0, 5.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.919, 0.324, 0.780, 1.000) Emissive scale: 0.01 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 CrashedShip_Interior SkyExplodedShipInteriorPowerCorridor Absorption: (7.0, 12.0, 20.0) Scattering: 0.02 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(0.919, 0.460, 0.324, 1.000) Emissive scale: 0.01 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Power SkyExplodedShipInteriorPowerRoom Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.662, 0.420, 0.365, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 crashZone_NoLoot SkyMountains Absorption: (100.0, 30.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.1 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 seaTreaderPath SkyMountains Absorption: (100.0, 33.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.08 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 seaTreaderPath_Cave_light SkyMountains Absorption: (100.0, 33.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.1 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.5 Ambient scale: 1 Temperature: 24 seaTreaderPath_Cave_dark SkyMountains Absorption: (100.0, 33.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.15 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 1 Temperature: 24 KelpForest_DenseVine SkyKelpForest Absorption: (140.0, 32.0, 47.0) Scattering: 1.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(0.934, 1.000, 0.000, 1.000) Emissive scale: 0.02 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 27 GrassyPlateaus_Tower SkyGrassyPlateaus Absorption: (10.0, 4.5, 3.0) Scattering: 0.4 Scattering color: RGBA(0.761, 0.761, 0.761, 1.000) Murkiness: 0.45 Emissive: RGBA(0.268, 0.499, 0.662, 1.000) Emissive scale: 0.06 Start distance: 35 Sunlight scale: 1.75 Ambient scale: 2 Temperature: 24 ILZCastleChamber SkyILZChamber Absorption: (0.5, 0.3, 1.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 2 Emissive: RGBA(1.000, 0.329, 0.154, 1.000) Emissive scale: 0.08 Start distance: 5 Sunlight scale: 0 Ambient scale: 0 Temperature: 60 InactiveLavaZone SkyMountains Absorption: (25.0, 10.0, 5.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 bloodKelpTwo SkyBloodKelpTwo Absorption: (35.0, 7.0, 5.5) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.15 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 bloodKelpTwo_Cave SkyBloodKelpTwo Absorption: (35.0, 6.5, 5.0) Scattering: 0.1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0.01 Start distance: 25 Sunlight scale: 0 Ambient scale: 0.7 Temperature: 24 LostRiver_BonesField SkyBonesField Absorption: (4.0, 2.0, 1.3) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.000, 0.561, 0.375, 1.000) Emissive scale: 0.2 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 LostRiver_BonesField_Skeleton SkyBonesField Absorption: (4.0, 2.0, 1.3) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.559, 0.374, 1.000) Emissive scale: 0.25 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 LostRiver_BonesField_Cave SkyBonesField Absorption: (4.0, 2.0, 1.3) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 2 Emissive: RGBA(0.000, 0.559, 0.485, 1.000) Emissive scale: 0.1 Start distance: 0 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 LostRiver_BonesField_Corridor SkyBonesField_Corridor Absorption: (3.0, 3.0, 2.0) Scattering: 0.1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.559, 0.374, 1.000) Emissive scale: 0.15 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 LostRiver_BonesField_Lake SkyBonesField Absorption: (10.0, 5.0, 2.5) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.243, 1.000, 0.467, 1.000) Emissive scale: 0.2 Start distance: 5 Sunlight scale: 0 Ambient scale: 1 Temperature: 39 LostRiver_BonesField_LakePit SkyBonesField Absorption: (12.0, 6.0, 3.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.243, 1.000, 0.467, 1.000) Emissive scale: 0.2 Start distance: 0 Sunlight scale: 0 Ambient scale: 1 Temperature: 39 LostRiver_BonesField_Corridor_Stream SkyBonesField_Corridor Absorption: (10.0, 5.0, 2.5) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.243, 1.000, 0.467, 1.000) Emissive scale: 0.3 Start distance: 0 Sunlight scale: 0 Ambient scale: 1 Temperature: 34 ILZCastleTunnel SkyILZChamber Absorption: (1.0, 1.0, 1.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 2 Emissive: RGBA(1.000, 0.329, 0.154, 1.000) Emissive scale: 0.08 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 60 ALZChamber SkyLavaLake Absorption: (0.3, 1.0, 1.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(1.000, 0.329, 0.154, 1.000) Emissive scale: 0.08 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 80 ALZFalls SkyLavaLake Absorption: (0.5, 1.0, 1.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(1.000, 0.329, 0.154, 1.000) Emissive scale: 0.08 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 70 Prison_UpperRoom SkyPrecursorPrisonAntechamber_NoLightmaps Absorption: (0.0, 0.0, 0.0) Scattering: 0.0001 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.001 Emissive: RGBA(0.601, 0.765, 0.444, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 Prison_Aquarium SkyPrecursorPrisonAquarium Absorption: (8.0, 4.5, 4.5) Scattering: 0.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.145, 0.302, 0.255, 1.000) Emissive scale: 0.4 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 21 ilzLava SkyILZChamber Absorption: (0.3, 1.0, 1.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.000, 0.000, 1.000) Murkiness: 1 Emissive: RGBA(1.000, 0.329, 0.154, 1.000) Emissive scale: 0.05 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 80 LostRiver_TreeCove SkyLostRiver_TreeCove Absorption: (2.0, 1.0, 0.5) Scattering: 0.1 Scattering color: RGBA(0.041, 0.125, 0.239, 1.000) Murkiness: 1 Emissive: RGBA(0.062, 0.109, 0.173, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 CrashedShip_Interior_ExoPipes SkyExplodedShipInteriorPipesRoom Absorption: (50.0, 40.0, 30.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.831, 0.507, 0.675, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Exo SkyExplodedShipInteriorExoRoom Absorption: (70.0, 110.0, 70.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.778, 0.691, 1.000, 1.000) Emissive scale: 0.05 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Locker SkyExplodedShipInteriorPowerCorridor Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.128, 0.173, 0.243, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Seamoth SkyExplodedShipInteriorPowerCorridor Absorption: (70.0, 110.0, 70.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.449, 0.402, 0.413, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Elevator SkyExplodedShipInteriorPowerCorridor Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.500, 0.344, 0.309, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Cargo SkyExplodedShipInteriorPowerCorridor Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1.5 Emissive: RGBA(0.394, 0.154, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Entrance_01_01 SkyExplodedShipInteriorEntrance_03 Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.128, 0.173, 0.243, 1.000) Emissive scale: 0.5 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Entrance_01_02 SkyExplodedShipInteriorEntrance_03 Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.394, 0.154, 1.000, 1.000) Emissive scale: 0.5 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Entrance_01_03 SkyExplodedShipInteriorEntrance_03 Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.394, 0.154, 1.000, 1.000) Emissive scale: 0.1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Entrance_02_01 SkyExplodedShipInteriorEntrance_03 Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.394, 0.154, 1.000, 1.000) Emissive scale: 0.1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Entrance_02_02 SkyExplodedShipInteriorEntrance_03 Absorption: (70.0, 110.0, 70.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1.5 Emissive: RGBA(0.394, 0.154, 1.000, 1.000) Emissive scale: 0.1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_Entrance_03 SkyExplodedShipInteriorEntrance_03 Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.500, 0.344, 0.309, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_PowerCorridor SkyExplodedShipInteriorPowerCorridor Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.500, 0.344, 0.309, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_LockerCorridor SkyExplodedShipInteriorPowerCorridor Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.500, 0.344, 0.309, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_SeamothRoom SkyExplodedShipInteriorSeamothRoom_02 Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.500, 0.344, 0.309, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_LivingArea SkyExplodedShipInteriorExoRoom Absorption: (80.0, 110.0, 70.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.394, 0.154, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_THallway SkyExplodedShipInteriorPowerCorridor Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.394, 0.154, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashedShip_Interior_THallwayLower SkyExplodedShipInteriorPowerCorridor Absorption: (50.0, 40.0, 30.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.394, 0.154, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 LavaLakes SkyLavaLake Absorption: (0.6, 0.3, 1.0) Scattering: 0.75 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.55 Emissive: RGBA(1.000, 0.329, 0.154, 1.000) Emissive scale: 0.05 Start distance: 65 Sunlight scale: 0 Ambient scale: 0 Temperature: 80 LavaFalls SkyLavaLake Absorption: (0.5, 1.0, 1.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(1.000, 0.329, 0.154, 1.000) Emissive scale: 0.08 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 70 LavaLakes_LavaPool SkyLavaLake Absorption: (0.5, 0.6, 1.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(1.000, 0.471, 0.157, 1.000) Emissive scale: 0.15 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 80 LavaPit SkyILZChamber Absorption: (3.0, 2.0, 1.5) Scattering: 0.1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.424, 0.588, 0.651, 1.000) Emissive scale: 0.03 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 60 Precursor_Gun_OuterRooms SkyPrecursorInterior_NoLightmaps Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.01 Emissive: RGBA(0.824, 0.922, 0.828, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 LostRiver_TreeCove_Water SkyLostRiver_TreeCove Absorption: (4.0, 4.0, 5.0) Scattering: 1 Scattering color: RGBA(0.000, 0.226, 0.275, 1.000) Murkiness: 0.4 Emissive: RGBA(0.000, 0.550, 0.667, 1.000) Emissive scale: 0.8 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 39 Precursor_Gun_MoonPoolWater SkyPrecursorInterior_NoLightmaps Absorption: (12.0, 10.0, 12.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.560, 0.603, 1.000) Emissive scale: 0.2 Start distance: 25 Sunlight scale: 0.5 Ambient scale: 1 Temperature: 24 Precursor_Gun_InnerRooms SkyPrecursorInterior_NoLightmaps Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.01 Emissive: RGBA(0.000, 0.560, 0.603, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 Precursor_Gun_ControlRoom SkyPrecursorInterior_NoLightmaps Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.01 Emissive: RGBA(0.000, 0.560, 0.603, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 Precursor_LostRiverBase SkyPrecursorInterior_LostRiverBase_NoLightmaps Absorption: (4.0, 2.0, 1.3) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.561, 0.378, 1.000) Emissive scale: 0.05 Start distance: 5 Sunlight scale: 0 Ambient scale: 0 Temperature: 14 Precursor_LavaCastleBase SkyPrecursorInterior_NoLightmaps Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.01 Emissive: RGBA(0.000, 0.560, 0.603, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 PrecursorThermalRoom SkyPrecursorInterior_NoLightmaps Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.01 Emissive: RGBA(0.000, 0.560, 0.603, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 LostRiver_TreeCove_Tree SkyLostRiver_TreeCove Absorption: (2.0, 1.0, 0.5) Scattering: 0.1 Scattering color: RGBA(0.041, 0.125, 0.239, 1.000) Murkiness: 1 Emissive: RGBA(0.062, 0.109, 0.173, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 underwaterIslands_Geyser SkyMountains Absorption: (25.0, 10.0, 5.0) Scattering: 0.8 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1 Ambient scale: 5 Temperature: 60 JellyshroomCaves_Geyser SkyJellyshroomCaves Absorption: (5.0, 4.0, 2.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.431, 0.392, 0.784, 1.000) Emissive scale: 0.035 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 60 LostRiver_GhostTree SkyLostRiver Absorption: (10.0, 8.0, 12.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.25 Emissive: RGBA(0.000, 0.216, 0.196, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 ilzChamber_Dragon SkyILZChamber Absorption: (0.1, 2.0, 2.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(0.451, 0.455, 0.271, 1.000) Emissive scale: 0.09 Start distance: 80 Sunlight scale: 0 Ambient scale: 0 Temperature: 60 LostRiver_Junction SkyLostRiver_Junction Absorption: (4.0, 2.0, 1.3) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.561, 0.378, 1.000) Emissive scale: 0.05 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 LostRiver_GhostTree_Lower SkyLostRiver Absorption: (10.0, 8.0, 12.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.28 Emissive: RGBA(0.000, 0.196, 0.176, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 LostRiver_GhostTree_Skeleton SkyLostRiver Absorption: (10.0, 8.0, 12.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.25 Emissive: RGBA(0.000, 0.216, 0.196, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 FloatingIslandCaveTeleporter SkyMountains Absorption: (10.0, 8.0, 12.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(0.353, 0.627, 0.706, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 LostRiver_Junction_Water SkyLostRiver_Junction Absorption: (10.0, 5.0, 2.5) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.243, 1.000, 0.462, 1.000) Emissive scale: 0.3 Start distance: 5 Sunlight scale: 0 Ambient scale: 1 Temperature: 39 mountains_teleporter SkyMountainsCaves Absorption: (40.0, 15.0, 9.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.3 Ambient scale: 0.2 Temperature: 24 sparseReef_Cave SkyMountains Absorption: (5.0, 4.0, 3.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(0.039, 0.075, 0.208, 1.000) Emissive scale: 0.1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0.5 Temperature: 24 sparseReef_Deep SkyMountains Absorption: (10.0, 2.8, 2.8) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.8 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.5 Ambient scale: 0.5 Temperature: 24 sparseReef_Spike SkyMountains Absorption: (10.0, 2.8, 2.8) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.8 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 sparseReef_Wreck SkyExplorableWreck Absorption: (5.0, 4.0, 3.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 1 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 1 Temperature: 24 precursorCache SkyPrecursorInterior Absorption: (10.0, 1.0, 2.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 3 Emissive: RGBA(0.075, 0.310, 0.231, 1.000) Emissive scale: 0.2 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 LostRiver_SkeletonCave SkyBonesField Absorption: (10.0, 4.0, 3.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.061, 0.243, 0.180, 1.000) Emissive scale: 0.5 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 LostRiver_SkeletonCave_Skeleton SkyBonesField Absorption: (4.0, 2.0, 1.3) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 3 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 LostRiver_Canyon SkyBonesField Absorption: (10.0, 3.0, 3.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.059, 0.243, 0.180, 1.000) Emissive scale: 0.5 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 CragField SkyMountains Absorption: (100.0, 33.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.1 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 PrecursorCave_Cragfield SkyMountains Absorption: (100.0, 33.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.1 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 Prison_Aquarium_Upper SkyPrecursorPrisonAquarium Absorption: (10.0, 4.5, 5.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.6 Emissive: RGBA(0.145, 0.302, 0.255, 1.000) Emissive scale: 0.4 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 21 Prison_Aquarium_Mid SkyPrecursorPrisonAquarium Absorption: (10.0, 4.5, 4.5) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.145, 0.302, 0.255, 1.000) Emissive scale: 0.25 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 21 Prison_Aquarium_Cave SkyMountains Absorption: (15.0, 10.0, 8.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.8 Emissive: RGBA(0.000, 0.204, 0.220, 1.000) Emissive scale: 1 Start distance: 5 Sunlight scale: 0 Ambient scale: 0 Temperature: 21 PrecursorCave_GhostTree SkyMountains Absorption: (20.0, 15.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.15 Emissive: RGBA(0.475, 0.838, 0.542, 1.000) Emissive scale: 0.02 Start distance: 5 Sunlight scale: 0 Ambient scale: 0 Temperature: 21 PrecursorCave_KooshZone SkyMountains Absorption: (20.0, 15.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.15 Emissive: RGBA(0.375, 0.375, 0.400, 1.000) Emissive scale: 0.12 Start distance: 5 Sunlight scale: 0 Ambient scale: 0 Temperature: 21 Prison_Antechamber SkyPrecursorPrisonAntechamber Absorption: (0.0, 0.0, 0.0) Scattering: 0.0001 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.001 Emissive: RGBA(0.600, 0.765, 0.443, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 Prison_Moonpool SkyPrecursorPrisonMoonpool Absorption: (0.0, 0.0, 0.0) Scattering: 0.0001 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.001 Emissive: RGBA(0.600, 0.765, 0.443, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 34 kooshZone_wreck SkyExplorableWreck Absorption: (30.0, 23.0, 12.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.14 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashZone_Mesa SkyCrashZone Absorption: (50.0, 20.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.15 Emissive: RGBA(0.004, 0.647, 0.129, 1.000) Emissive scale: 0.03 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 24 Dunes_wreck SkyExplorableWreck Absorption: (20.0, 10.0, 6.0) Scattering: 0.5 Scattering color: RGBA(0.341, 0.427, 0.447, 1.000) Murkiness: 0.2 Emissive: RGBA(0.102, 0.133, 0.149, 1.000) Emissive scale: 0.2 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 LostRiver_Corridor SkyLostRiver_Junction Absorption: (4.0, 2.0, 1.3) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.561, 0.376, 1.000) Emissive scale: 0.05 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 LostRiver_Corridor_ThermalVents SkyLostRiver_Junction Absorption: (4.0, 2.0, 1.3) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.561, 0.376, 1.000) Emissive scale: 0.05 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 underwaterIslands_wreck SkyExplorableWreck Absorption: (25.0, 10.0, 5.0) Scattering: 0.8 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 mountains_wreckinterior SkyExplorableWreck Absorption: (40.0, 15.0, 9.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.12 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 bloodKelp_wreck SkyExplorableWreck Absorption: (50.0, 8.0, 4.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 seaTreaderPath_wreck SkyExplorableWreck Absorption: (100.0, 33.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.8 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 mushroomForest_wreck SkyExplorableWreck Absorption: (100.0, 30.0, 20.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.05 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 grandReef_wreck SkyExplorableWreck Absorption: (16.0, 12.0, 6.0) Scattering: 2 Scattering color: RGBA(0.000, 1.000, 0.910, 1.000) Murkiness: 0.25 Emissive: RGBA(0.000, 0.957, 1.000, 1.000) Emissive scale: 0.03 Start distance: 40 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 CrashZone_Trench SkyCrashZone Absorption: (17.0, 20.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(1.000, 1.000, 1.000, 1.000) Emissive scale: 0 Start distance: 5 Sunlight scale: 0.75 Ambient scale: 1 Temperature: 24 BZ Biome Settings: Biome name Sky name Settings arctic SkyArcticSurface Absorption: (125.0, 20.0, 4.0) Scattering: 1.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1.5 Temperature: 0 sparseArctic SkyArcticSurface Absorption: (150.0, 15.0, 3.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 35 Sunlight scale: 1.2 Ambient scale: 1.5 Temperature: 0 glacialBay SkyArcticSurface Absorption: (35.0, 5.0, 3.0) Scattering: 1 Scattering color: RGBA(0.016, 0.840, 0.758, 1.000) Murkiness: 0.7 Emissive: RGBA(0.495, 0.991, 0.792, 1.000) Emissive scale: 0.05 Start distance: 35 Sunlight scale: 1 Ambient scale: 1 Temperature: 0 arcticKelp SkyKelpForest Absorption: (5.0, 1.5, 2.0) Scattering: 0.25 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 3 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 35 Sunlight scale: 1 Ambient scale: 1.25 Temperature: 20 twistyBridges SkyTwistyBridges Absorption: (35.0, 5.0, 3.0) Scattering: 1 Scattering color: RGBA(0.000, 0.534, 0.440, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.868, 1.000, 1.000) Emissive scale: 0.02 Start distance: 30 Sunlight scale: 1.1 Ambient scale: 0.5 Temperature: 4 twistyBridges_Shallow SkyTwistyBridges_Shallow Absorption: (25.0, 9.0, 3.0) Scattering: 0.385 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.239, 1.000, 0.886, 1.000) Emissive scale: 0.03 Start distance: 20 Sunlight scale: 1.2 Ambient scale: 0.6 Temperature: 6 twistyBridges_OuterCave SkyTwistyBridges_ShallowCave Absorption: (35.0, 5.0, 3.0) Scattering: 1 Scattering color: RGBA(0.000, 0.534, 0.440, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.851, 1.000, 1.000) Emissive scale: 0.04 Start distance: 15 Sunlight scale: 0.4 Ambient scale: 1.1 Temperature: 6 twistyBridges_Cave SkyTwistyBridges_ShallowCave Absorption: (35.0, 5.0, 3.0) Scattering: 1 Scattering color: RGBA(0.000, 0.534, 0.440, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.851, 1.000, 1.000) Emissive scale: 0.04 Start distance: 15 Sunlight scale: 0 Ambient scale: 1.1 Temperature: 6 twistyBridges_InnerCave SkyTwistyBridges_ShallowCave Absorption: (35.0, 5.0, 3.0) Scattering: 1 Scattering color: RGBA(0.000, 0.534, 0.440, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.851, 1.000, 1.000) Emissive scale: 0.02 Start distance: 15 Sunlight scale: 0 Ambient scale: 1.1 Temperature: 6 twistyBridges_Cave_Sanctuary SkyTwistyBridges_ShallowCave Absorption: (35.0, 5.0, 3.0) Scattering: 1 Scattering color: RGBA(0.000, 0.534, 0.440, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.851, 1.000, 1.000) Emissive scale: 0.02 Start distance: 15 Sunlight scale: 0 Ambient scale: 1.1 Temperature: 6 lilyPads SkyLilyPads Absorption: (20.0, 5.0, 6.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.45 Emissive: RGBA(0.180, 0.604, 0.404, 1.000) Emissive scale: 0.05 Start distance: 20 Sunlight scale: 1 Ambient scale: 1.25 Temperature: 20 lilyPads_Islands SkyLilyPads Absorption: (20.0, 5.0, 6.0) Scattering: 0.6 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.45 Emissive: RGBA(0.180, 0.604, 0.404, 1.000) Emissive scale: 0.05 Start distance: 20 Sunlight scale: 1 Ambient scale: 1.25 Temperature: 20 lilyPads_Islands_Cave SkyLilyPads Absorption: (20.0, 5.0, 6.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.6 Emissive: RGBA(0.180, 0.604, 0.285, 1.000) Emissive scale: 0.4 Start distance: 10 Sunlight scale: 0 Ambient scale: 1 Temperature: 20 lilyPads_MegaIsland_CaveInterior SkyLilyPads_MegaIsland_CaveInterior Absorption: (20.0, 5.0, 6.0) Scattering: 0.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.45 Emissive: RGBA(0.180, 0.604, 0.404, 1.000) Emissive scale: 0.05 Start distance: 20 Sunlight scale: 0.5 Ambient scale: 1 Temperature: 20 lilyPads_MegaIsland_CaveCorridor SkyLilyPads_MegaIsland_CaveCorridor Absorption: (20.0, 5.0, 6.0) Scattering: 0.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.45 Emissive: RGBA(0.180, 0.604, 0.404, 1.000) Emissive scale: 0.02 Start distance: 20 Sunlight scale: 0.25 Ambient scale: 1 Temperature: 20 lilyPads_ShipWreck SkyLilyPads Absorption: (20.0, 5.0, 6.0) Scattering: 0.6 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.35 Emissive: RGBA(0.180, 0.604, 0.404, 1.000) Emissive scale: 0.013 Start distance: 25 Sunlight scale: 1 Ambient scale: 1.25 Temperature: 20 thermalSpires SkyThermalSpires Absorption: (30.0, 12.0, 8.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.063, 0.137, 0.196, 1.000) Emissive scale: 0.5 Start distance: 25 Sunlight scale: 1 Ambient scale: 1.5 Temperature: 25 thermalSpires_cave SkyThermalSpiresCave Absorption: (5.0, 2.0, 1.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.75 Emissive: RGBA(0.519, 0.432, 0.277, 1.000) Emissive scale: 0.2 Start distance: 15 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 35 thermalSpiresDeep SkyThermalSpiresCave Absorption: (30.0, 12.0, 8.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.75 Emissive: RGBA(0.063, 0.137, 0.196, 1.000) Emissive scale: 0.5 Start distance: 25 Sunlight scale: 1 Ambient scale: 0.8 Temperature: 45 purpleVents SkyPurpleVents Absorption: (8.0, 7.0, 7.0) Scattering: 0.35 Scattering color: RGBA(0.404, 0.616, 0.800, 1.000) Murkiness: 0.65 Emissive: RGBA(0.000, 0.165, 0.216, 1.000) Emissive scale: 5 Start distance: 24 Sunlight scale: 1 Ambient scale: 1.5 Temperature: 20 purpleVents_ShipWreck SkyPurpleVents Absorption: (8.0, 7.0, 7.0) Scattering: 0.5 Scattering color: RGBA(0.404, 0.616, 0.800, 1.000) Murkiness: 0.65 Emissive: RGBA(0.000, 0.165, 0.216, 1.000) Emissive scale: 5 Start distance: 24 Sunlight scale: 1 Ambient scale: 1.5 Temperature: 40 purpleVents_Deep SkyDeepPurpleVents Absorption: (8.0, 7.0, 7.0) Scattering: 0.35 Scattering color: RGBA(0.404, 0.616, 0.800, 1.000) Murkiness: 0.65 Emissive: RGBA(0.000, 0.165, 0.216, 1.000) Emissive scale: 5 Start distance: 24 Sunlight scale: 0 Ambient scale: 1.5 Temperature: 40 purpleVents_Crevice SkyDeepPurpleVents Absorption: (8.0, 7.0, 7.0) Scattering: 0.35 Scattering color: RGBA(0.404, 0.616, 0.800, 1.000) Murkiness: 0.65 Emissive: RGBA(0.000, 0.165, 0.216, 1.000) Emissive scale: 5 Start distance: 24 Sunlight scale: 0.5 Ambient scale: 1.5 Temperature: 40 crystalCave SkyTwistyBridges_Deep Absorption: (5.0, 5.0, 5.5) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.403, 0.528, 0.981, 1.000) Emissive scale: 0.2 Start distance: 20 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 crystalCave_Fissure SkyTwistyBridges_Deep Absorption: (6.0, 3.5, 6.5) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.508, 0.584, 0.282, 1.000) Emissive scale: 0.25 Start distance: 5 Sunlight scale: 0 Ambient scale: 0 Temperature: 50 crystalCave_Vent SkyTwistyBridges_Deep Absorption: (6.0, 3.5, 6.5) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.508, 0.584, 0.282, 1.000) Emissive scale: 0.25 Start distance: 5 Sunlight scale: 0 Ambient scale: 0 Temperature: 80 fabricatorcaverns SkyTwistyBridges_Deep Absorption: (4.0, 3.0, 6.0) Scattering: 0.1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.6 Emissive: RGBA(0.118, 0.510, 0.659, 1.000) Emissive scale: 0.2 Start distance: 30 Sunlight scale: 0 Ambient scale: 0 Temperature: 6 deepArctic SkyTwistyBridges_Deep Absorption: (125.0, 20.0, 4.0) Scattering: 1.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.18 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1.5 Temperature: -2 kelpForest SkyKelpForest Absorption: (7.0, 4.5, 4.5) Scattering: 1.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.2 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 5 lilyPads_Deep SkyDeepLily Absorption: (5.0, 5.5, 6.5) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(1.000, 0.906, 0.973, 1.000) Emissive scale: 0.12 Start distance: 18 Sunlight scale: 0 Ambient scale: 1 Temperature: 1 lilyPads_Deep_Cache SkyDeepLily Absorption: (0.0, 0.0, 0.0) Scattering: 0.25 Scattering color: RGBA(0.000, 0.533, 0.439, 1.000) Murkiness: 1 Emissive: RGBA(0.800, 0.784, 1.000, 1.000) Emissive scale: 0.01 Start distance: 0 Sunlight scale: 0 Ambient scale: 1.1 Temperature: 6 lilyPads_Deep_GiantFlower SkyDeepLily Absorption: (10.0, 11.0, 15.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.23 Emissive: RGBA(0.027, 0.152, 0.220, 1.000) Emissive scale: 1 Start distance: 0 Sunlight scale: 0 Ambient scale: 2 Temperature: 1 twistyBridges_Deep SkyTwistyBridges_Deep Absorption: (12.0, 12.0, 7.0) Scattering: 0.25 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.45 Emissive: RGBA(0.533, 0.463, 0.867, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 30 twistyBridges_Deep_thermal SkyTwistyBridges_Deep Absorption: (12.0, 12.0, 7.0) Scattering: 0.25 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.533, 0.463, 0.867, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 55 introIceCave_Entrance SkyintroIceCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.533, 0.463, 0.867, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0.1 Ambient scale: 0.8 Temperature: 1 introIceCave SkyintroIceCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.533, 0.463, 0.867, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 1 RocketAreaIceCave SkyintroIceCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.089, 0.771, 0.868, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 1 RocketAreaIceCave_Entrance SkyintroIceCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.485, 0.820, 0.868, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0.1 Ambient scale: 0.8 Temperature: 1 RocketAreaRockCave SkyKelpCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.838, 0.639, 0.210, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 1 RocketAreaRockCave_Entrance SkyKelpCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.860, 0.772, 0.582, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0.1 Ambient scale: 0.8 Temperature: 1 startZone SkyArcticSurface Absorption: (150.0, 15.0, 3.0) Scattering: 0.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 35 Sunlight scale: 1.2 Ambient scale: 1.5 Temperature: 0 ArcticKelp_CaveInner SkyKelpCave Absorption: (30.0, 25.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.15 Emissive: RGBA(0.353, 0.431, 0.157, 1.000) Emissive scale: 1 Start distance: 8 Sunlight scale: 0 Ambient scale: 0 Temperature: 30 ArcticKelp_CaveOuter SkyKelpCave Absorption: (30.0, 25.0, 20.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.15 Emissive: RGBA(0.353, 0.431, 0.157, 1.000) Emissive scale: 1 Start distance: 8 Sunlight scale: 0 Ambient scale: 0 Temperature: 24 startZone_Cave SkyTwistyBridges Absorption: (35.0, 5.0, 2.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.533, 0.439, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.851, 1.000, 1.000) Emissive scale: 0.05 Start distance: 15 Sunlight scale: 0 Ambient scale: 1.1 Temperature: 6 startZone_Cave_Entrance SkyTwistyBridges Absorption: (35.0, 5.0, 2.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.533, 0.439, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.851, 1.000, 1.000) Emissive scale: 0.07 Start distance: 15 Sunlight scale: 0.5 Ambient scale: 1.1 Temperature: 6 Precursor_Sanctuary SkyPrecursorSanctuaryCave Absorption: (35.0, 5.0, 2.0) Scattering: 1 Scattering color: RGBA(0.000, 0.533, 0.439, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.851, 1.000, 1.000) Emissive scale: 0.07 Start distance: 15 Sunlight scale: 0 Ambient scale: 1.1 Temperature: 6 Precursor_Sanctuary_Cave SkyPrecursorSanctuaryCave Absorption: (35.0, 5.0, 2.0) Scattering: 1 Scattering color: RGBA(0.000, 0.533, 0.439, 1.000) Murkiness: 0.5 Emissive: RGBA(0.000, 0.851, 1.000, 1.000) Emissive scale: 0.02 Start distance: 15 Sunlight scale: 0 Ambient scale: 1.1 Temperature: 6 treespires SkyTreeSpires Absorption: (5.0, 4.0, 2.0) Scattering: 0.3 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.75 Emissive: RGBA(0.757, 0.447, 1.000, 1.000) Emissive scale: 0.1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 30 treespires_bigtree SkyTreeSpires Absorption: (5.0, 4.0, 2.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.75 Emissive: RGBA(0.757, 0.447, 1.000, 1.000) Emissive scale: 0.1 Start distance: 25 Sunlight scale: 1 Ambient scale: 1 Temperature: 25 treespires_bigfissure SkyTreeSpires Absorption: (6.0, 10.0, 3.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.757, 0.447, 1.000, 1.000) Emissive scale: 0.05 Start distance: 25 Sunlight scale: 0 Ambient scale: 1 Temperature: 50 treespires_smallfissure SkyTreeSpires Absorption: (8.0, 10.0, 3.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.000, 1.000, 0.975, 1.000) Emissive scale: 0.1 Start distance: 25 Sunlight scale: 1.5 Ambient scale: 1 Temperature: 40 GlacialBasin_Bunker SkyBaseInterior Absorption: (255.0, 255.0, 255.0) Scattering: 0 Scattering color: RGBA(0.000, 0.000, 0.000, 1.000) Murkiness: 0.48 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 3 GlacialBasin_GlacialCave SkyGlacialCavesIce Absorption: (255.0, 255.0, 255.0) Scattering: 0 Scattering color: RGBA(0.000, 0.000, 0.000, 1.000) Murkiness: 0.48 Emissive: RGBA(0.724, 0.908, 0.953, 1.000) Emissive scale: 0 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 3 GlacialBasin_CreatureCave SkyintroIceCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.533, 0.463, 0.867, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 3 GlacialBasin_DarkCave SkyPrecursorInterior_Dark Absorption: (255.0, 255.0, 255.0) Scattering: 0 Scattering color: RGBA(0.000, 0.000, 0.000, 1.000) Murkiness: 3 Emissive: RGBA(0.000, 0.000, 0.000, 1.000) Emissive scale: 0 Start distance: 0 Sunlight scale: 0 Ambient scale: 0 Temperature: 3 GlacialBasin_HoverBikeBase SkyintroIceCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.533, 0.463, 0.867, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.4 Temperature: 3 GlacialBasin_BlueIceCave SkyintroIceCave Absorption: (12.0, 6.0, 6.0) Scattering: 1 Scattering color: RGBA(0.108, 0.608, 0.915, 1.000) Murkiness: 0.7 Emissive: RGBA(0.724, 0.908, 0.953, 1.000) Emissive scale: 0.5 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 3 GlacialBasin_Overhang SkyGlacialBasin Absorption: (128.0, 32.0, 32.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.725, 0.906, 0.953, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0.5 Ambient scale: 0 Temperature: 3 GlacialBasin_IceLakeSurface SkyTwistyBridges_Shallow Absorption: (25.0, 9.0, 3.0) Scattering: 0.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.8 Emissive: RGBA(0.529, 0.000, 1.000, 1.000) Emissive scale: 0.01 Start distance: 20 Sunlight scale: 1.2 Ambient scale: 0.6 Temperature: 3 GlacialBasin_TemperateCave SkyintroIceCave Absorption: (12.0, 6.0, 6.0) Scattering: 0 Scattering color: RGBA(0.000, 0.579, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.707, 0.802, 0.723, 1.000) Emissive scale: 2.45 Start distance: 5 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 3 glacialBasin_Underwater SkyTreeSpires Absorption: (20.0, 10.0, 4.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.141, 0.204, 0.388, 1.000) Emissive scale: 0.05 Start distance: 25 Sunlight scale: 0 Ambient scale: 0.2 Temperature: 0 glacialBasin SkyGlacialBasin Absorption: (25.0, 25.0, 3.0) Scattering: 0.06 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.724, 0.908, 0.953, 1.000) Emissive scale: 0.05 Start distance: 35 Sunlight scale: 1 Ambient scale: 1.5 Temperature: 0 MiningSite SkyMiningSite Absorption: (25.0, 15.0, 20.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.5 Emissive: RGBA(0.953, 0.858, 0.725, 1.000) Emissive scale: 0.1 Start distance: 35 Sunlight scale: 0 Ambient scale: 1.5 Temperature: 0 wreck SkyWreck Absorption: (25.0, 7.0, 12.0) Scattering: 0.4 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.051, 0.486, 0.620, 1.000) Emissive scale: 0.3 Start distance: 0 Sunlight scale: 0 Ambient scale: 1.5 Temperature: 0 CrystalCave_Cache SkyCrystalCaverns Absorption: (3.0, 5.0, 8.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.35 Emissive: RGBA(0.380, 0.373, 0.906, 1.000) Emissive scale: 0.3 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 0 CrystalCave_Castle SkyTwistyBridges_Deep Absorption: (6.0, 5.0, 5.5) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.8 Emissive: RGBA(0.380, 0.373, 0.906, 1.000) Emissive scale: 0.4 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 0 CrystalCave_Inner SkyTwistyBridges_Deep Absorption: (5.0, 5.0, 5.5) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.403, 0.528, 0.981, 1.000) Emissive scale: 0.2 Start distance: 20 Sunlight scale: 0 Ambient scale: 0 Temperature: 40 GlacialConnection SkyTreeSpires Absorption: (10.0, 5.0, 4.0) Scattering: 1.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.141, 0.204, 0.388, 1.000) Emissive scale: 0.5 Start distance: 25 Sunlight scale: 0 Ambient scale: 0.2 Temperature: 0 Glacier SkyTreeSpires Absorption: (20.0, 10.0, 4.0) Scattering: 2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.3 Emissive: RGBA(0.141, 0.204, 0.388, 1.000) Emissive scale: 1 Start distance: 25 Sunlight scale: 1 Ambient scale: 0.2 Temperature: 0 margBase SkyKelpCave Absorption: (5.0, 3.0, 5.0) Scattering: 0.8 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.6 Emissive: RGBA(0.176, 0.336, 0.604, 1.000) Emissive scale: 0.4 Start distance: 20 Sunlight scale: 0 Ambient scale: 1 Temperature: 25 margBase_Base SkyKelpCave Absorption: (5.0, 3.0, 5.0) Scattering: 0.8 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.6 Emissive: RGBA(0.180, 0.604, 0.526, 1.000) Emissive scale: 0.13 Start distance: 20 Sunlight scale: 0 Ambient scale: 1 Temperature: 30 margBase_Base_Interior SkyKelpCave Absorption: (6.0, 2.0, 1.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.4 Emissive: RGBA(0.604, 0.604, 0.604, 1.000) Emissive scale: 0.1 Start distance: 10 Sunlight scale: 0 Ambient scale: 1 Temperature: 0 treespires_Thermal SkyTreeSpires Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0 Emissive: RGBA(0.604, 0.604, 0.604, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 60 thermalSpires_Thermal SkyThermalSpires Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0 Emissive: RGBA(0.604, 0.604, 0.604, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 35 thermalVent_Thermal SkyThermalSpires Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0 Emissive: RGBA(0.604, 0.604, 0.604, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 100 lava_Thermal SkyThermalSpires Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0 Emissive: RGBA(0.604, 0.604, 0.604, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 200 purpleVent_Thermal SkyThermalSpires Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0 Emissive: RGBA(0.604, 0.604, 0.604, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 50 hotsprings_Thermal SkyThermalSpires Absorption: (0.0, 0.0, 0.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0 Emissive: RGBA(0.604, 0.604, 0.604, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 40 lilypads_crevice SkyKelpCave Absorption: (5.0, 3.0, 5.0) Scattering: 1 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.6 Emissive: RGBA(0.115, 0.623, 0.403, 1.000) Emissive scale: 0.12 Start distance: 15 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 lilypads_megatrench SkyKelpCave Absorption: (20.0, 5.0, 6.0) Scattering: 0.7 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.180, 0.604, 0.525, 1.000) Emissive scale: 0.15 Start distance: 20 Sunlight scale: 0.75 Ambient scale: 0 Temperature: 1 arcticeast_iceberg_cavehigh SkyKelpCave Absorption: (20.0, 5.0, 6.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.290, 0.717, 1.000) Murkiness: 1 Emissive: RGBA(0.332, 0.524, 0.774, 1.000) Emissive scale: 0.9 Start distance: 10 Sunlight scale: 0.5 Ambient scale: 0 Temperature: 1 arcticeast_iceberg_cavelow SkyKelpCave Absorption: (20.0, 5.0, 6.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.161, 0.388, 1.000) Murkiness: 2 Emissive: RGBA(0.196, 0.353, 0.557, 1.000) Emissive scale: 0.4 Start distance: 10 Sunlight scale: 0.1 Ambient scale: 0 Temperature: 1 lilypads_crevice_exit SkyKelpCave Absorption: (20.0, 5.0, 6.0) Scattering: 0.6 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.6 Emissive: RGBA(0.145, 0.678, 0.510, 1.000) Emissive scale: 0.13 Start distance: 20 Sunlight scale: 0.2 Ambient scale: 0.25 Temperature: 1 lilypads_crevice_open SkyKelpCave Absorption: (20.0, 5.0, 6.0) Scattering: 0.6 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.6 Emissive: RGBA(0.145, 0.678, 0.510, 1.000) Emissive scale: 0.13 Start distance: 20 Sunlight scale: 0.3 Ambient scale: 1 Temperature: 1 EastArctic SkyIceberg Absorption: (10.0, 5.0, 4.0) Scattering: 0.6 Scattering color: RGBA(0.000, 0.571, 0.745, 1.000) Murkiness: 0.4 Emissive: RGBA(0.099, 0.287, 0.396, 1.000) Emissive scale: 0.2 Start distance: 50 Sunlight scale: 1 Ambient scale: 1 Temperature: 1 arcticCaldera SkyMiningSite Absorption: (10.0, 5.0, 4.0) Scattering: 0.6 Scattering color: RGBA(0.000, 0.571, 0.745, 1.000) Murkiness: 0.4 Emissive: RGBA(0.099, 0.287, 0.396, 1.000) Emissive scale: 0.2 Start distance: 50 Sunlight scale: 1 Ambient scale: 1 Temperature: 1 WestArctic SkyIceberg Absorption: (10.0, 5.0, 4.0) Scattering: 1.5 Scattering color: RGBA(0.000, 0.571, 0.745, 1.000) Murkiness: 0.5 Emissive: RGBA(0.099, 0.287, 0.396, 1.000) Emissive scale: 0.2 Start distance: 50 Sunlight scale: 0.8 Ambient scale: 1 Temperature: 1 EastArctic_IceBerg_Cave_Light SkyIceberg Absorption: (20.0, 10.0, 5.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.571, 0.745, 1.000) Murkiness: 0.4 Emissive: RGBA(0.099, 0.287, 0.396, 1.000) Emissive scale: 0.2 Start distance: 20 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 WestArctic_IceBerg_Cave_Light SkyIceberg Absorption: (20.0, 10.0, 5.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.571, 0.745, 1.000) Murkiness: 0.4 Emissive: RGBA(0.099, 0.287, 0.396, 1.000) Emissive scale: 0.1 Start distance: 20 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 EastArctic_IceBerg_Cave_Dark SkyIceberg Absorption: (20.0, 10.0, 5.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.570, 0.745, 1.000) Murkiness: 0.8 Emissive: RGBA(0.155, 0.299, 0.415, 1.000) Emissive scale: 0.2 Start distance: 10 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 WestArctic_IceBerg_Cave_Dark SkyIceberg Absorption: (20.0, 10.0, 5.0) Scattering: 0.2 Scattering color: RGBA(0.000, 0.570, 0.745, 1.000) Murkiness: 0.8 Emissive: RGBA(0.155, 0.299, 0.415, 1.000) Emissive scale: 0.4 Start distance: 10 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 EastArctic_IceBerg_CaveSealed_Dark SkyIceberg Absorption: (20.0, 10.0, 5.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.498, 0.651, 1.000) Murkiness: 0.8 Emissive: RGBA(0.196, 0.353, 0.557, 1.000) Emissive scale: 0.1 Start distance: 10 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 WestArctic_IceBerg_CaveSealed_Dark SkyIceberg Absorption: (20.0, 10.0, 5.0) Scattering: 0.1 Scattering color: RGBA(0.000, 0.498, 0.651, 1.000) Murkiness: 0.8 Emissive: RGBA(0.196, 0.353, 0.557, 1.000) Emissive scale: 0.1 Start distance: 10 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 EastArctic_IceBerg_CaveSurface_Dark SkyIceberg Absorption: (20.0, 10.0, 5.0) Scattering: 0.1 Scattering color: RGBA(0.000, 0.498, 0.651, 1.000) Murkiness: 0.1 Emissive: RGBA(0.196, 0.395, 0.557, 1.000) Emissive scale: 0.1 Start distance: 6 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 WestArctic_IceBerg_CaveSurface_Dark SkyIceberg Absorption: (10.0, 5.0, 2.5) Scattering: 0.05 Scattering color: RGBA(0.000, 0.498, 0.651, 1.000) Murkiness: 0.1 Emissive: RGBA(0.196, 0.395, 0.557, 1.000) Emissive scale: 0.1 Start distance: 6 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 Lilypads_BaseInterior SkyLilyPads_BaseInterior Absorption: (20.0, 5.0, 6.0) Scattering: 0.2 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.45 Emissive: RGBA(0.180, 0.604, 0.404, 1.000) Emissive scale: 0.05 Start distance: 3 Sunlight scale: 0 Ambient scale: 1 Temperature: 1 arcticSpires SkyGlacialBasin Absorption: (20.0, 10.0, 5.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.498, 0.651, 1.000) Murkiness: 0.1 Emissive: RGBA(0.196, 0.395, 0.557, 1.000) Emissive scale: 0.05 Start distance: 6 Sunlight scale: 1 Ambient scale: 1.3 Temperature: 0 OutpostZero_Interior SkyOutpostZero_Interior Absorption: (20.0, 10.0, 5.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.498, 0.651, 1.000) Murkiness: 0.1 Emissive: RGBA(0.196, 0.395, 0.557, 1.000) Emissive scale: 0.05 Start distance: 6 Sunlight scale: 1 Ambient scale: 1.3 Temperature: 0 WorldEdge SkyIceberg Absorption: (10.0, 5.0, 4.0) Scattering: 0.5 Scattering color: RGBA(0.000, 0.498, 0.651, 1.000) Murkiness: 0.4 Emissive: RGBA(0.098, 0.286, 0.396, 1.000) Emissive scale: 0.2 Start distance: 25 Sunlight scale: 0.1 Ambient scale: 6 Temperature: 1 EndGameAsteroids SkyAsteroids Absorption: (10.0, 5.0, 4.0) Scattering: 0.5 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0 Emissive: RGBA(0.098, 0.286, 0.396, 1.000) Emissive scale: 0 Start distance: 25 Sunlight scale: 0 Ambient scale: 0 Temperature: 1 ArcticSpiresCache SkyKelpCave Absorption: (12.0, 12.0, 7.0) Scattering: 0 Scattering color: RGBA(1.000, 1.000, 1.000, 1.000) Murkiness: 0.7 Emissive: RGBA(0.838, 0.639, 0.210, 1.000) Emissive scale: 0.13 Start distance: 12 Sunlight scale: 0 Ambient scale: 0.8 Temperature: 1"
  },
  "tutorials/console-commands.html": {
    "href": "tutorials/console-commands.html",
    "title": "Adding Custom Console Commands",
    "summary": "Adding Custom Console Commands Nautilus provides a simple API for allowing you to define custom console commands for your mod to respond to when the user types them into the in-game dev console, with simple parameter type checking to enable user- and developer-friendly error reporting, both on-screen and in the log. Supported Parameter Types Currently, only the following types are supported by the API: string bool int float double If you wish to use a type not in this list, it is recommended to use string (as that is what the value coming from the user will be anyway) and handle converting and error-checking the value for yourself. If the user provides incorrect parameters for a command, they will be notified of the expected parameters on-screen and in the log file. Registering a Custom Console Command There are three ways to register custom console commands, so you can use whichever suits your purpose or coding-style best. Warning Registered commands must be unique. If any mod has already added the command, your command will be rejected. Note A command can have a return type, but it is not necessary. If it does return any type, it will be printed on-screen and in the log file. Registering a delegate (Callback) as a Command By calling ConsoleCommandsHandler.RegisterConsoleCommand<T>(string command, T callback), you can pass an instance of the delegate, whether it is an anonymous lambda or reference to a method that implements the delegate signature to register your callback as a response to the command. Note that with a delegate command, it is not possible to use optional parameters. If you want optional parameters, it is recommended to register a public static method as a command instead. In the example below, we are registering a console command by the use of a delegate. The delegate will respond to the \"delegatecommand\" command from the dev console in the game. You can also use System.Func or System.Action delegates to define the signature for your command signature. using BepInEx; using Nautilus.Handlers; [BepInPlugin(PluginInfo.GUID, PluginInfo.MOD_NAME, PluginInfo.VERSION)] public class MyPlugin : BaseUnityPlugin { private void Start() { ConsoleCommandsHandler.RegisterConsoleCommand<MyCommand>(\"delegatecommand\", (myString, myInt, myBool) => { return $\"Parameters: {myString} {myInt} {myBool}\"; }); } private delegate string MyCommand(string myString, int myInt, bool myBool); } The command: delegatecommand foo 3 true is a valid signature for the code above. Registering a public static Method as a Command By calling ConsoleCommandsHandler.RegisterConsoleCommand(string command, Type declaringType, string methodName, Type[] parameters = null), you can specify a public static method as a response to the command. The API here is similar to Harmony in that it will search for the method in the given type, using the optional Type[] parameters to target overloads. In the example below, we are registering a console command by specifying a target method. The method will respond to the \"methodcommand\" command from the dev console in the game. using BepInEx; using Nautilus.Handlers; [BepInPlugin(PluginInfo.GUID, PluginInfo.MOD_NAME, PluginInfo.VERSION)] public class MyPlugin : BaseUnityPlugin { private void Start() { ConsoleCommandsHandler.RegisterConsoleCommand(\"methodcommand\", typeof(MyMod), nameof(MyCommand)); Logger.LogInfo(\"Patched successfully!\"); } public static string MyCommand(string myString, int myInt, bool myBool = false) { return $\"Parameters: {myString} {myInt} {myBool}\"; } } The command: methodcommand foo 3 true is a valid signature for the code above. Registering Multiple public static Methods Within a Class as Commands By calling ConsoleCommandsHandler.RegisterConsoleCommands(Type type), you can register all public static methods decorated with the ConsoleCommandAttribute as console commands. In the example below, we are registering all console commands specified in the MyConsoleCommands types as console commands. Methods decorated with the ConsoleCommandAttribute will respond to the specified command from the dev console in the game. using BepInEx; using Nautilus.Commands; using Nautilus.Handlers; [BepInPlugin(PluginInfo.GUID, PluginInfo.MOD_NAME, PluginInfo.VERSION)] public class MyPlugin : BaseUnityPlugin { private void Start() { ConsoleCommandsHandler.RegisterConsoleCommands(typeof(MyConsoleCommands)); Logger.Log(Logger.Level.Info, \"Patched successfully!\"); } } public static class MyConsoleCommands { /// The MyAttributedCommand method will respond to the \"attributedcommand\" command from the dev console. [ConsoleCommand(\"attributedcommand\")] public static string MyAttributedCommand(string myString, int myInt, bool myBool = false) { return $\"Parameters: {myString} {myInt} {myBool}\"; } } The commands: attributedcommand foo 3 true attributedcommand foo 3 are both valid signatures for the code above. Note Optional arguments can be ignored when executing a command in the dev console. When ignored, the specified default value will be used instead."
  },
  "tutorials/craft-tree-paths.html": {
    "href": "tutorials/craft-tree-paths.html",
    "title": "SN1 Crafting Tree Paths",
    "summary": "SN1 Crafting Tree Paths List of default crafting tree paths for use in the CraftingGadget.WithStepsToFabricatorTab(...) method, alongside any of the methods in the CraftTreeHandler class. Remember that paths divided by slashes must always be separate strings when used in Nautilus functions. For example: // EX1: Add the prefab to the Advanced Materials tab. craftingGadget.WithStepsToFabricatorTab(\"Resources\", \"AdvancedMaterials\"); // EX2: Add the prefab to the root of the fabricator. craftingGadget.WithStepsToFabricatorTab(); // EX3: Add the prefab to the Vehicles tab of the mobile vehicle bay. craftingGadget.WithFabricatorType(CraftTree.Type.Constructor) .WithStepsToFabricatorTab(\"Vehicles\"); Fabricator (Fabricator): Resources BasicMaterials (Basic Materials) [Craft nodes] AdvancedMaterials (Advanced Materials) [Craft nodes] Electronics [Craft nodes] Survival Water [Craft nodes] CookedFood (Cooked food) [Craft nodes] CuredFood (Cured food) [Craft nodes] Personal Equipment [Craft nodes] Tools [Craft nodes] Machines [Craft nodes] Simplified list of paths Resources/BasicMaterials Resources/AdvancedMaterials Resources/Electronics Survival/Water Survival/CookedFood Survival/CuredFood Personal/Equipment Personal/Tools Machines Workbench (Modification station): Not applicable; all crafting nodes are located in the root. Constructor (Mobile vehicle bay): Vehicles [Craft nodes] Rocket [Craft nodes] Simplified list of paths Vehicles Rocket CyclopsFabricator: Not applicable; all crafting nodes are located in the root. Centrifuge: Not applicable; all crafting nodes are located in the root. MapRoom (Scanner Room Fabricator): Not applicable; all crafting nodes are located in the root. SeamothUpgrades (Vehicle Upgrade Console): CommonModules (Common Modules) [Craft nodes] SeamothModules (Seamoth Modules) [Craft nodes] ExosuitModules (Prawn Suit Modules) [Craft nodes] Torpedoes (Torpedoes) [Craft nodes] Simplified list of paths CommonModules SeamothModules ExosuitModules Torpedoes"
  },
  "tutorials/crafting-recipes.html": {
    "href": "tutorials/crafting-recipes.html",
    "title": "Editing Crafting Recipes",
    "summary": "Editing Crafting Recipes Recipes in Subnautica are combining one or multiple items to craft a new and more advanced item in various crafting stations. Nautilus offers the RecipeData class with sufficient data for recipes. Below is a table of all the parameters you may interact with in the RecipeData class. Parameter Name Type Description craftAmount int Amounts of copies of the item that is created for this recipe. Ingredients List<TechType> A list of ingredients required for this recipe. LinkedItems List<TechType> Items that will also be created when this recipe is crafted. To register or edit recipes, use the Nautilus.Handlers.CraftDataHandler.SetRecipeData() method. Examples The following examples demonstrate the usage of the SetRecipeData method. // Set the Titanium Ingot's recipe to only two titaniums RecipeData titaniumIngotRecipe = new RecipeData(new CraftData.Ingredient(TechType.Titanium, 2)); // register the recipe CraftDataHandler.SetRecipeData(TechType.TitaniumIngot, titaniumIngotRecipe); // Make the scrap metal recipe yield 10 titaniums instead of 5 RecipeData scrapMetalRecipe = new RecipeData { // We don't want to get a new scrap metal in this recipe, so it should be 0. craftAmount = 0, // Require a scrap metal for the recipe Ingredients = { new CraftData.Ingredient(TechType.ScrapMetal) }, // Yield 10 titaniums when crafted LinkedItems = Enumerable.Repeat(TechType.Titanium, 10).ToList() }; // register the recipe CraftDataHandler.SetRecipeData(TechType.ScrapMetal, scrapMetalRecipe); See also SetRecipeData() SetRecipeData() RecipeData"
  },
  "tutorials/csproj-tutorials.html": {
    "href": "tutorials/csproj-tutorials.html",
    "title": "Customizing your C# project",
    "summary": "Customizing your C# project This page contains several small tutorials for customizing and improving your development environment. Many sections expect that you have used the mod templates as shown here. Changing Plugin Info Plugins such as the BepInEx configuration manager and the Subnautica Mod Manager will show users your mod's display name. Your mod's version may be used for version/dependency checking. Other mods will need to use your mod's GUID for dependencies and compatibility. All of these values are automatically generated but can be changed by editing your csproj file. Changing Plugin Version: This is generally the easiest property to set because the Version tag is already present in the csproj by default. Example: <Version>1.0.0</Version> Please do not use semver here! BepInEx 5 does NOT support semver. You may also use the BepInExPluginVersion tag if you want more control over this. Changing Plugin Name: You must add the BepInExPluginName tag to edit the Name. I suggest putting this into the same property group as the Version tag. Example: <BepInExPluginName>Project Neptune</BepInExPluginName> Changing Plugin GUID: You must add the BepInExPluginGuid tag to edit the GUID. I suggest putting this into the same property group as the Version tag. Example: <BepInExPluginGuid>com.snmodding.projectneptune</BepInExPluginGuid> Note For the sake of consistency, we recommend you use reverse-DNS naming for your GUIDs, i.e. \"com.authorname.modname`. Automatic DLL copying It is possible to use post-build scripts that automatically place your mod's DLL into the BepInEx plugins folder right after you hit Build. Step 1 In the same folder as your csproj, create a file named \"GameDir.targets\". This should be the entire contents of the file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"> <PropertyGroup> <!--If trying to build this project, please make sure the correct directory to your Subnautica folder is listed below:--> <GameDir>C:\\Program Files (x86)\\Steam\\steamapps\\common\\Subnautica</GameDir> </PropertyGroup> </Project> Edit the GameDir property's value if needed so the path matches your local Subnautica directory. If you understand GitHub well enough, I highly recommend adding this file to your project's gitignore. Step 2 Open your csproj file as shown below: Outside of any PropertyGroups, add the following (the comments are optional!): <!--Imports the GameDir.targets file (from the same folder) which should contain the path to the Subnautica directory for the post-build event--> <Import Project=\"GameDir.targets\" /> This basically allows the rest of the csproj file to easily access your GameDir.targets file, and makes the GameDir property usable. Step 3 Still in the csproj, add the following outside of any PropertyGroups: <!--Defines the PluginsDir property for use in the Post-Build event--> <PropertyGroup> <PluginsDir>$(GameDir)\\BepInEx\\plugins</PluginsDir> </PropertyGroup> You shouldn't have to change this. Step 4 Finally, once again in the csproj outside of any PropertyGroups, add the following: <!--Post-Build event that automatically places your mods folder with the DLL and documentation into your plugins folder as defined in GameDir.targets--> <Target Name=\"PostBuild\" AfterTargets=\"PostBuildEvent\"> <MakeDir Directories=\"$(PluginsDir)\\$(TargetName)\" /> <Copy SourceFiles=\"$(TargetPath)\" DestinationFolder=\"$(PluginsDir)\\$(TargetName)\" /> </Target> If you want to do the same for a .pdb file, add this to just before </Target>: <Copy SourceFiles=\"$(TargetDir)\\(TargetName).pdb\" DestinationFolder=\"$(PluginsDir)\\$(TargetName)\" /> Make sure a folder exists in the BepInEx/plugins folder with the same name as your mod DLL. If everything went correctly, upon building your project the DLL should be automatically placed in the correct location, meaning you do not have to manually move the DLL anymore!"
  },
  "tutorials/databank-entries.html": {
    "href": "tutorials/databank-entries.html",
    "title": "Adding Custom Databank Entries",
    "summary": "Adding Custom Databank Entries Important The terms \"Databank\", \"Encyclopedia\" and \"Ency\" are used interchangeably throughout the game, its codebase and in mods. These are also referred to as \"PDA Entries\". Keep all of this in mind! The PDA’s Databank is essential for providing players with large blocks of text that would otherwise take too long to read. These entries can also contain a custom image or audio file embedded within to enhance the player’s understanding of the information. It is recommended to set up an Asset Bundle for Databank entries that involve custom assets. Asset Bundles simplify the process of loading assets to a single line per call, regardless of file type. Creating a Databank entry through Nautilus This tutorial will be based around the PDAHandler.AddEncyclopediaEntry(...) method. The method listed above is the most straightforward way to register a custom entry to the game through Nautilus. Therefore, the following sections on entry creation will elaborate upon all of the parameters. Keep in mind that simply creating a PDA entry is usually not enough. You must also determine how it is unlocked. The Main Components of a Databank Entry Key Parameter name Value type Nullability key string Essential property; must be assigned a proper value! Every PDA Databank entry has its own internal key (also referred to as an ID) which ensures uniqueness, allows for saving, and connects it with other systems. For example, a Story Goal that unlocks a Databank entry should have the same key / ID as the entry that it unlocks. Path Parameter name Value type Nullability path string Essential property; must be assigned a proper value! Every PDA entry has its own \"path\" which determines where in the PDA this entry is found. A typical path looks something like Lifeforms/Fauna/Leviathans. Click here for a list of standard Databank paths Path Display Name Tech Blueprints Welcome Survival Package Welcome/StartGear Additional Technical Tech/Habitats Habitat Installations Tech/Equipment Equipment Tech/Vehicles Vehicles Tech/Power Power Lifeforms Indigenous Lifeforms Lifeforms/Coral Coral Lifeforms/Fauna Fauna Lifeforms/Flora Flora Lifeforms/Flora/Land Land Lifeforms/Flora/Sea Sea Lifeforms/Flora/Exploitable Exploitable Lifeforms/Fauna/Herbivores Herbivores (UNUSED) Lifeforms/Fauna/Carnivores Carnivores Lifeforms/Fauna/Rays Rays (UNUSED) Lifeforms/Fauna/Sharks Sharks (UNUSED) Lifeforms/Fauna/Leviathans Leviathans Lifeforms/Fauna/Other Other Predators (UNUSED) Lifeforms/Fauna/SmallHerbivores Herbivores - Small Lifeforms/Fauna/LargeHerbivores Herbivores - Large Lifeforms/Fauna/Scavengers Scavengers & Parasites Lifeforms/Fauna/Deceased Deceased PlanetaryGeology Geological Data Advanced Advanced Theories DownloadedData Data Downloads DownloadedData/BeforeCrash Operations Logs DownloadedData/PublicDocs Public Documents DownloadedData/Degasi Degasi Survivors DownloadedData/Degasi/Orders Alterra Search & Rescue Mission DownloadedData/Lifepods CORRUPTED (UNUSED) DownloadedData/AuroraSurvivors Aurora Survivors DownloadedData/Codes Codes & Clues DownloadedData/Precursor Alien Data DownloadedData/Precursor/Terminal Terminal Data DownloadedData/Precursor/Scan Scan Data DownloadedData/Precursor/Artifacts Artifacts TimeCapsules Time Capsules You can also create your own paths. When doing this, make sure you set the language line properly. The key for a path in the language system is EncyPath_{path}, e.g. EncyPath_Lifeforms/Fauna/Leviathans. Example of custom path creation // Manual localization handling in case you choose to not use JSON localization LanguageHandler.SetLanguageLine(\"EncyPath_Lifeforms/Fauna/Pets\", \"Pets\"); LanguageHandler.SetLanguageLine(\"EncyPath_Lifeforms/Fauna/Pets/Robotic\", \"Robotic Pets\"); // Adds \"Doggo\" to the \"Pets\" category: PDAHandler.AddEncyclopediaEntry(\"Doggo\", \"Lifeforms/Fauna/Pets\" ...); // Adds \"Robot Dog\" to the \"Robotic\" category which is a subcategory of \"Pets\": PDAHandler.AddEncyclopediaEntry(\"Robot Dog\", \"Lifeforms/Fauna/Pets/Robotic\" ...); Title and Description Parameter name Value type Nullability title string Can be null if implementing proper localization. desc string Can be null if implementing proper localization. Adding the text content is very simple as it is composed of only two strings that must be passed into the method. Alternatively, you can use JSON-based localization and leave both the title and desc parameters as null. Note It is recommended to use JSON-based localization in your mod (as opposed to embedding lengthy text in your code) to allow for user translations. Primary image Parameter name Value type Nullability image UnityEngine.Texture2D Can safely be left unassigned. The image of a Databank entry is its primary visual element. Each entry can have up to one image. Creating your own image assets: You can make your own Databank images, but it is recommended that you are consistent with the vanilla style of the game. Photoshop is recommended, as it was used to make these originally, but any image editor can work. These tend to use the Agency FB font. Stock images are often used in the \"close up\" areas. A blank template for these is provided below: Important Please keep in mind that it is ILLEGAL to use Subnautica's art assets and style in other contexts. However, Unknown Worlds Entertainment has given modders permission to modify their assets for non-commercial purposes within Subnautica mods. Popup images Parameter name Value type Nullability popupImage UnityEngine.Sprite Can safely be left unassigned. Uses a default image. The popup image is a rather insignificant image that can be applied to your Databank entries. This small image appears to the left side of the screen for a few seconds when your entry is unlocked. Creating your own popup images: These images should follow the rules below: Typically 256x128 pixels. The image is usually cropped so only a decent portion of the render fits in the space. The contents NEVER extend to the rightmost side of the image. The contents typically do not extend to the left side of the image. If nearing the left side, the leftmost corners must always be cut out. This image can be used as a template for cutting out the corners: A complete popup image looks like this: Unlock sound Parameter name Value type Nullability unlockSound FMODAsset Can safely be left unassigned, but will be automatically resolved to the default sound. By default the unlockSound parameter is null. This will be automatically resolved to PDAHandler.UnlockBasic. While you can technically use any sound asset, the only other recommended sound is PDAHandler.UnlockImportant. Voice logs Parameter name Value type Nullability voiceLog FMODAsset Can safely be left unassigned. The sounds for audio logs must first be registered through the CustomSoundHandler class. The overload that takes an AudioClip is recommended due to its simplicity. It is also suggested to use the AudioUtils.BusPaths.VoiceOvers bus. After registering a sound, you must make an FMODAsset. An FMODAsset essentially acts as a container for your sound path. To create one use the AudioUtils.GetFmodAsset(string) method, where the path is the ID that you just defined in the CustomSoundHandler. Finally, just pass this FMODAsset into the voiceLog parameter of the original method. Usage Examples Example 1 - Localization embedded into code Registers a new PDA entry with a main image, popup image and English title / description as defined in the code. // Load the popup image, which is a basic Texture2D Texture2D image = assetBundle.LoadAsset<Texture2D>(\"EldritchLogImage\"); // Popup images, on the other hand, must be imported as Sprites Sprite popup = assetBundle.LoadAsset<Sprite>(\"EldritchLogSprite\"); string title = \"Eldritch's Log\"; string description = \"I took one of the lifepods all for myself.\\n\\nIt's actually kind of lonely in here..\"; // Since the title and description are passed into the method, Nautilus will internally assign the English // lines to the localization keys 'Ency_EldritchLog' and 'EncyDesc_EldritchLog' respectively // Register the encyclopedia entry into the game: PDAHandler.AddEncyclopediaEntry(\"EldritchLog\", \"DownloadedData/PublicDocs\", title, description, image, popup); Example 2 - Localization handled by JSON files (recommended) Registers a new PDA entry with a voice log, popup image and support for custom translations. Expects external JSON files or similar for localization. // Remember: popup images must be imported as Sprites Sprite popup = assetBundle.LoadAsset<Sprite>(\"KallieLogSprite\"); // Register the custom sound into FMOD... // The sound's ID can be anything, but it must correspond with the FMOD asset that will be created. CustomSoundHandler.RegisterCustomSound(\"KallieAudioLog\", assetBundle.LoadAsset<AudioClip>(\"AudioFileName\"), AudioUtils.BusPaths.VoiceOvers); // Create an FMOD asset using the same ID as the sound to pass into the method FMODAsset kallieLogSound = AudioUtils.GetFmodAsset(\"KallieAudioLog\"); // When null values are used for the title and description parameters in AddEncyclopediaEntry, Nautilus expects // localization lines defined for the keys \"Ency_YourEntryIdHere\" (title) and \"EncyDesc_YourEntryIdHere\" (description) // Register the encyclopedia entry into the game: PDAHandler.AddEncyclopediaEntry(\"KalliesLog\", \"DownloadedData/PublicDocs\", null, null, null, popup, kallieLogSound); /* English.json example: * { * \"Ency_KalliesLog\": \"Kallie's Log\", * \"EncyDesc_KalliesLog\": \"[Transcript of the voice log]\" * } */ Making entries unlockable Tip The ency [key] command can be used to instantly unlock a Databank entry for testing purposes. PDA entries are not unlocked by default, but there are various ways to add them to the player’s databank. Some methods are listed below: Method Notes Story Goal completion Only occurs when GoalType is GoalType.Encyclopedia. See our documentation on the StoryGoalHandler class for more info. PDAHandler.AddCustomScannerEntry(...) Unlocks the PDA entry on scanning the \"key\" TechType. Make sure to set the encyclopediaKey parameter to the key of your encyclopedia entry. PDAEncyclopedia.AddAndPlaySound(string key) Adds the entry with the given key, shows a notification, and plays the correct sound (if defined) for this entry. PDAEncyclopedia.Add(string key, bool verbose) Adds the entry with the given key, and shows a notification if verbose is true. Example for unlocking with PDAHandler.AddCustomScannerEntry: // Register encyclopedia entry like usual: PDAHandler.AddEncyclopediaEntry(\"ArcticReaperEncy\", \"Lifeforms/Fauna/Leviathans\", \"Arctic Reaper\", \"A reaper leviathan that lives in a colder climate.\"); // Use PDAHandler.AddCustomScannerEntry to make it unlockable. // This code unlocks the encyclopedia entry when a prefab with a TechType of ArcticReaperTechType is scanned. PDAHandler.AddCustomScannerEntry(ArcticReaperTechType, 4, false, \"ArcticReaperEncy\"); Example for unlocking with Story Goals: // Register encyclopedia entry like usual: PDAHandler.AddEncyclopediaEntry(\"SpadefishHate\", \"Advanced\", \"Spadefish are terrible\", \"Why do they lay eggs? Why do they damage your seamoth so badly?\"); // Use the StoryGoalHandler to make it unlockable. // This particular example uses the RegisterItemGoal method to unlock the encyclopedia entry when picking up a Spadefish: StoryGoalHandler.RegisterItemGoal(\"SpadefishHate\", Story.GoalType.Encyclopedia, TechType.Spadefish);"
  },
  "tutorials/equipment-type.html": {
    "href": "tutorials/equipment-type.html",
    "title": "",
    "summary": "What are equipment types? EquipmentType is an enum that handles special items. The possible values for this enum are listed below. public enum EquipmentType { None, // Normal item Hand, // The item can be equipped in the Hand slot Head, // The item can be equipped in the Head slot Body, // The item can be equipped in the Body slot Gloves, // The item can be equipped in the Gloves slot Foots, // The item can be equipped in the Feet slot Tank, // The item can be equipped in the Oxygen Tank slot Chip, // The item can be equipped in the Chip slots CyclopsModule, // The item can be equipped in the Cyclops as an upgrade module VehicleModule, // The item can be equipped both in the Seamoth and in the Prawn Suit as an upgrade module NuclearReactor, // The item can be used in a Nuclear Reactor BatteryCharger, // When batteries are thrown in it, they get charged (for buildables) PowerCellCharger, // When power cells are thrown in it, they get charged (for buildables) SeamothModule, // The item can be equipped in the Seamoth as an upgrade module ExosuitModule, // The item can be equipped in the Prawn Suit as an upgrade module ExosuitArm, // The item can be equipped in the Prawn Suit as an arm DecoySlot // (Need actual name) Possibly for the decoy tube thing in the cyclops } How can I create a custom background type? Since equipment types are simply just enums, we can use the enum handler to create a new instance. private void Awake() { var myCustomEquipmentType = EnumHandler.AddEntry<EquipmentType>(\"CustomEquipmentType\"); } And that's it. Now you can use the new CraftData.BackgroundType instance anywhere you want. How can edit an item's equipment type? To edit an item's equipment type, you need to call the CraftDataHandler.SetEquipmentType method sitting in the Nautilus.Handlers namespace Examples The following example demonstrates the usage of SetEquipmentType that enables the player to wear titanium on their head. CraftDataHandler.SetEquipmentType(TechType.Titanium, EquipmentType.Head); Similarly, if we wanted to set the titanium's equipment type to our custom equipment type from earlier, it would look like the following: CraftDataHandler.SetBackgroundType(TechType.Titanium, myCustomEquipmentType); If you're setting the equipment type for a custom prefab, we recommend using the ICustomPrefab.SetEquipment method instead. var customPrefab = new CustomPrefab(\"CustomItem\", \".\", \".\"); customPrefab.SetEquipment(EquipmentType.Head); // rest of the custom prefab configuration is omitted for brevity. Warning It is dangerous to edit equipment types for items that already have one, because they can break. For instance, modifying the equipment type for the Radiation Helmet will disable the player from wearing it."
  },
  "tutorials/loading-and-instantiating-prefabs.html": {
    "href": "tutorials/loading-and-instantiating-prefabs.html",
    "title": "Loading and instantiating prefabs",
    "summary": "Loading and instantiating prefabs In Subnautica, objects are created (obviously). Peepers spawn in the water around you. Titanium appears when outcrops are broken. Your Seamoth is built in front of you as soon as you craft it. But how exactly is this done, and how can you recreate this in your own mods? In reality, there are countless ways to spawn prefabs into the world. Chances are some have not even been discovered yet. Each method has its ups and downs, so it's a good idea to be familiar with all of them. Important If you are accessing a prefab for reference purposes (like reusing its materials for another prefab), then please do NOT instantiate it. Instead, access the prefab that was loaded directly, without calling the Instantiate method. This works perfectly fine. You should only call Instantiate if you want it to appear in the world. Important Some prefabs (often modded ones) may be inactive by default, so it is suggested to call SetActive(true) on any instances of newly instantiated prefab. Asynchronous loading As of the Living Large update, both SN1 and Below Zero use asynchronous prefab loading. Therefore, prefab loading now must always be handled within coroutines, because the loading occurs across multiple frames. Please note that this is not a guide on coroutines. You can look that up on your own; they have been extensively explained online. Also take note of the UWE.CoroutineHost.StartCoroutine(IEnumerator) method. This amazing utility method provided by Subnautica lets you execute a coroutine at any point in your mod, without needing your own MonoBehaviour to host it. Note Resources.Load should no longer be used. The game does NOT use the Resources folder for managing prefabs. Instead, Unknown Worlds has begun using Unity's Addressable Asset System. Luckily, the game has many utilities that interact with that for us. Methods of loading prefabs CraftData.GetPrefabForTechTypeAsync public static CoroutineTask<GameObject> GetPrefabForTechTypeAsync(TechType techType, bool verbose = true) This is arguably the most simple way of loading prefabs. This method only takes a TechType and returns a coroutine task. A coroutine task holds a reference to the prefab once it is complete. However, it will not be loaded instantly. You must write yield return task to await its completion. Only then can you safely call its GetResult() method. Example code that spawns a Peeper in front of the player: private static IEnumerator SpawnPeeper() { // Fetch the prefab: CoroutineTask<GameObject> task = CraftData.GetPrefabForTechTypeAsync(TechType.Peeper); // Wait for the prefab task to complete: yield return task; // Get the prefab: GameObject prefab = task.GetResult(); // Instantiate the prefab with a random rotation 2 meters in front of the player camera: Instantiate(prefab, MainCamera.camera.transform.position + (MainCamera.camera.transform.forward * 2), Random.rotation); } Bare minimum code with inferred typing: private static IEnumerator SpawnPeeper() { var task = CraftData.GetPrefabForTechTypeAsync(TechType.Peeper); yield return task; var prefab = task.GetResult(); } UWE.PrefabDatabase.GetPrefabAsync public static IPrefabRequest GetPrefabAsync(string classId) Instead of a TechType, this method requires a Class ID. While some prefabs have TechTypes, almost every prefab has a Class IDs. Of course, there are exceptions. Certain visual effects and projectiles do not have Class IDs. Special \"scene objects\" such as the player, Aurora and Cyclops are also unable to be spawned in this way. The downside of this method is that the Class IDs are not part of the game's assemblies like TechTypes are. This means you must find the Class ID yourself and the compiler will not autocomplete them for you. For your convenience, a list of all Class IDs can be found here. Do note that a list has not been made for Below Zero yet. Example code that spawns a Peeper behind the player: using UWE; // ... private static IEnumerator SpawnPeeper() { // Fetch the prefab (3fcd548b-781f-46ba-b076-7412608deeef is the Class ID of the Peeper): IPrefabRequest task = UWE.PrefabDatabase.GetPrefabAsync(\"3fcd548b-781f-46ba-b076-7412608deeef\"); // Wait for the prefab task to complete: yield return task; // Get the prefab: task.TryGetPrefab(out GameObject prefab); // Instantiate the prefab with a random rotation 2 meters behind the player camera: Instantiate(prefab, MainCamera.camera.transform.position - (MainCamera.camera.transform.forward * 2), Random.rotation); } Bare minimum code with inferred typing: private static IEnumerator SpawnPeeper() { var task = UWE.PrefabDatabase.GetPrefabAsync(\"3fcd548b-781f-46ba-b076-7412608deeef\"); yield return task; task.TryGetPrefab(out var prefab); } UWE.PrefabDatabase.GetPrefabForFilenameAsync public static IPrefabRequest GetPrefabForFilenameAsync(string filename) This method is similar to PrefabDatabase.GetPrefabAsync but takes a file path as opposed to a Class ID. If you are familiar with Resources.Load from before the Living Large update, the paths here are very similar to the ones used in that method. The Class ID list also contains the file path of every prefab on the right side. Make sure to include the .prefab extension and exclude the Assets/AddressableResources/ prefix. Example code that spawns a Peeper above the player: using UWE; // ... private static IEnumerator SpawnPeeper() { // Fetch the prefab: IPrefabRequest task = UWE.PrefabDatabase.GetPrefabForFilenameAsync(\"WorldEntities/Creatures/Peeper.prefab\"); // Wait for the prefab task to complete: yield return task; // Get the prefab: task.TryGetPrefab(out GameObject prefab); // Instantiate the prefab with a random rotation 2 meters above the player camera: Instantiate(prefab, MainCamera.camera.transform.position + (MainCamera.camera.transform.up * 2), Random.rotation); } Bare minimum code with inferred typing: private static IEnumerator SpawnPeeper() { var task = UWE.PrefabDatabase.GetPrefabForFilenameAsync(\"WorldEntities/Creatures/Peeper.prefab\"); yield return task; task.TryGetPrefab(out var prefab); } When to use each method For most purposes, CraftData.GetPrefabForTechTypeAsync(TechType) can be the only thing you use. TechTypes are convenient, and most functional prefabs have one. There is no reason not to use this unless the prefab you need is lacking a TechType. PrefabDatabase.GetPrefabAsync and PrefabDatabase.GetPrefabForFilenameAsync can be used interchangeably. The former generally takes up less space in terms of characters. However the paths in the latter are definitely more readable than Class IDs. Whichever you want to use is up to you."
  },
  "tutorials/loading-screens.html": {
    "href": "tutorials/loading-screens.html",
    "title": "Custom Loading Screens",
    "summary": "Custom Loading Screens Nautilus provides a way for modders to add custom loading screens, which is tied in with the custom title screen system. Note This tutorial builds off the one for the custom title screens tutorial, so if you have not already, it's highly recommended to go through that first. System Summary The loading screen system consists of two parts. The current custom title screen, handled by Nautilus's TitleScreenHandler Custom LoadingScreenData, which handles image registration and how loading screens are selected. For a loading screen to be available to be selected, the specified CustomTitleData key must be the active theme. Once that check has passed, Nautilus looks at the parameters on each LoadingScreenData itself. Here are all the parameters required for creating a LoadingScreenData instance: loadingScreenImage: The loading screen sprite. This is the actual image that will show. priority: The priority of this loading screen over other registered screens. timeToNextScreen: The duration in seconds for which this loading screen will stay active. storyGoalRequirement: A story goal requirement for the loading screen to be enabled (not required). customRequirement: A custom requirement for the loading screen to be enabled (not required). Loading Screen Example private void RegisterLoadingScreens() { // The \"ModTitleAddons\" theme will need to be active for these screens to show up LoadingScreenHandler.RegisterLoadingScreen(\"ModTitleAddons\", new [] { // Register a simple loading screen with just a sprite new LoadingScreenHandler.LoadingScreenData(Plugin.AssetBundle.LoadAsset<Sprite>(\"LoadingSprite1\")), // Register a loading screen with the \"MyEpicStoryGoal\" story goal requirement new LoadingScreenHandler.LoadingScreenData(Plugin.AssetBundle.LoadAsset<Sprite>(\"LoadingSprite2\"), storyGoalRequirement: \"MyEpicStoryGoal\"), // Register a loading screen that only appears when the \"storyBool\" in the mod's save data is set to true new LoadingScreenHandler.LoadingScreenData(Plugin.AssetBundle.LoadAsset<Sprite>(\"LoadingSprite3\"), customRequirement: () => Plugin.SaveData.storyBool), }) }"
  },
  "tutorials/localization.html": {
    "href": "tutorials/localization.html",
    "title": "Localization",
    "summary": "Localization In Subnautica, localization is a key-value string dataset where the key represents a unique identifier that is the same on all languages, and the value represents the translation in a language. Nautilus provides a few different approaches to go about adding localization in the LanguageHandler class. Json Files Localization The most common method of adding localization in game development is via json files where the json file name represents the language name (I.E: English.json for English). The json files contain a key-value pair where the key is the language key and the value is the translation. Examples The following examples demonstrate the usage of json-file-based localizations. Json files: // English.json { \"TitaniumClone\": \"Titanium Clone\", \"Tooltip_TitaniumClone\": \"Titanium clone that makes me go yes.\" } // Spanish.json { \"TitaniumClone\": \"Clon de Titanio\", \"Tooltip_TitaniumClone\": \"Clon de Titanio que me hace decir que sí\" } To register json-file-based localizations, all you will have to call is one line of code: LanguageHandler.RegisterLocalizationFolder(); Note By default, Nautilus expects these json files to be located in the {modFolder}/Localization folder. The following example registers the Translations folder as the localization folder: LanguageHandler.RegisterLocalizationFolder(\"Translations\"); Dictionary Localization Nautilus also offers to register string key-value dataset as localization. Examples The following examples demonstrate the usage of dictionary-based localization. Dictionary<string, string> _languageEntriesEng = new() { { \"TitaniumClone\", \"Titanium Clone\" }, { \"Tooltip_TitaniumClone\", \"Titanium clone that makes me go yes.\" } }; Dictionary<string, string> _languageEntriesEsp = new() { { \"TitaniumClone\", \"Clon de Titanio\" }, { \"Tooltip_TitaniumClone\", \"Clon de Titanio que me hace decir que sí\" } }; // Register our English language entries to the English language LanguageHandler.RegisterLocalization(\"English\", _languageEntriesEng); // Register our Spanish language entries to the Spanish language LanguageHandler.RegisterLocalization(\"Spanish\", _languageEntriesEsp); Singular Translation Another approach that can be used is translating one key to any desired language. Additionally, all Nautilus methods that interact with language keys also offer modders to choose the language to translate for. Examples The following examples demonstrate the usage of singular translations. LanguageHandler.SetLanguageLine(\"TitaniumClone\", \"Titanium Clone\", \"English\"); LanguageHandler.SetLanguageLine(\"TitaniumClone\", \"Clon de Titanio\", \"Spanish\"); // Adds Spanish translation instead of English PrefabInfo info = PrefabInfo.WithTechType(\"TitaniumClone\", \"Clon de Titanio\", \"Clon de Titanio que me hace decir que sí\", \"Spanish\"); See also LanguageHandler"
  },
  "tutorials/options.html": {
    "href": "tutorials/options.html",
    "title": "Adding Options",
    "summary": "Adding Options Most mods will require/use some sort of user configuration from hotkeys to values to colors. Nautilus offers a wrapper to help easily create an entry in the settings for your mods options. Depending on the use case you can use a super simple ConfigFile or a more detailed and customizable ModOptions. ConfigFile A ConfigFile is the simplest way of managing your mod's options automatically. This is ideal if you just want a basic plain config with little custom functionality. The ConfigFile by itself is just a class which automatically stores persistent data to disk but with the addition of custom Attributes you can make it display nicely in game too. Creating your ConfigFile The following code is an example of how you could represent an integer value with a slider in game: using Nautilus.Json; using Nautilus.Options.Attributes; /// The Menu attribute allows us to set the title of our section within the \"Mods\" tab of the options menu. [Menu(\"My Options Menu\")] public class MyConfig : ConfigFile { /// A Slider attribute is used to represent a numeric value as a slider in the options menu with a /// minimum and maximum value. By default, the minimum value is 0 and maximum is 100. /// /// In this example we are setting a minimum value of 0 and a maximum of 50, with a /// DefaultValue of 25 which will be represented by a notch on the slider. [Slider(\"My slider\", 0, 50, DefaultValue = 25)] /// This is the actual definition for the value which should be saved. Its value controls the /// initial value that our option will have upon opening the game for the first time. public int SliderValue = 15; } See Attributes for a full list of available control types and attribute arguments. ModOptions A ModOptions is the more advanced way of managing your mod's options. This is ideal if you require more customization than is provided or want to manage your mods config separately (eg via BepInEx config). The ModOptions by itself is just a class which helps display your options nicely in game and relies on other classes to persist data across game loads (eg BepInEx config). OptionItems are added to your section with the AddItem function. When options are added to the list they will only be created once, this means that if they are changed outside of Nautilus (ex. BepInEx ConfigurationManager) they will not be updated inside of the Nautilus mods window. In order to refresh your values on every opening of the menu you must override ModOptions.BuildModOptions which is executed once every time the menu is opened. Creating your ModOptions The following code is an example of how you could represent an integer value with a slider in game: using Nautilus.Options; /// Inherit from the abstract ModOptions public class MyModOptions : ModOptions { /// The base ModOptions class takes a string name as an argument public MyModOptions() : base(\"My Mod Options\") { /// A ModSliderOption is used to draw a numeric value as a slider in the options menu with a /// minimum and maximum value. /// /// In this example we are setting a minimum value of 0 a maximum of 50, a /// DefaultValue of 25 (which will be represented by a notch on the slider) /// and an initial value of 15. AddItem(ModSliderOption.Create(\"SliderId\", \"My Slider\", 0, 50, 15, 25)); } } Saving your config As mentioned above, a ModOptions does not handle saving and retrieving config from disk and as such it does not persist across saves by default. One of the most convenient ways of accounting for this is to utilize BepInEx as a config store (we have it, may as well use it!). There are a few ways to accomplish this: (1) (Recommended) Using the builtin extensions for converting BepInEx ConfigEntry instances to OptionItem instances. See ConfigEntryExtensions for possible options. (2) Manually hooking to an external (likely BepInEx) config with individual OnChanged. See reacting to changed values (individual) below for further explanation on the details. (3) Manually hooking to an external (likely BepInEx) config with the global OnChanged. See reacting to changed values (global) below for further explanation on the details. In all cases, in order to support changes made outside of Nautilus (ex. BepInEx ConfigurationManager) you will need to override ModOptions.BuildModOptions which is executed once every time the menu is opened. Reacting to changed values Nautilus provides three different ways of dealing with changed values when using ModOptions: (1) Adding a listener to an OptionItem OnChanged. (2) Adding a listener to the global OnChanged event. This method is the most similar to SML 2.0's change handler. (3) A combination of (1) and (2) Individual OnChanged Every ModOption has a certain subclass of OptionEventArgs (eg ToggleChangedEventArgs) which is passed to the option's OnChanged event. You can add your own function to the OnChanged for it to be run whenever the value is changed as shown below: using Nautilus.Options; public class MyModOptions : ModOptions { public MyModOptions() : base(\"My Mod Options\") { OnChanged += Options_Changed; var Slider1 = ModSliderOption.Create(\"Slider1\", \"My Slider\", 0, 50, 15, 25); Slider1_OnChanged += Slider1_OnChanged; AddItem(Slider1); var Toggle1 = ModToggleOption.Create(\"Toggle1\", \"My Toggle\", true); Toggle1_OnChanged += Toggle1_OnChanged; AddItem(Toggle1); var Toggle2 = ModToggleOption.Create(\"Toggle2\", \"My Other Toggle\", true); Toggle2_OnChanged += (object sender, ToggleChangedEventArgs e) => { /// Handle changes here }; AddItem(Toggle2); } private void Slider1_OnChanged(object sender, SliderChangedEventArgs e) { /// Handle changes here } private void Toggle1_OnChanged(object sender, ToggleChangedEventArgs e) { /// Handle changes here } } Global OnChanged The base ModOptions has an OnChanged which every individual option OnChanged bubbles up to. You can add your own handler function to this class but you will need to differentiate between each type/individual option which can be done multiple ways. An example class may look like: using Nautilus.Options; public class MyModOptions : ModOptions { public MyModOptions() : base(\"My Mod Options\") { OnChanged += Options_Changed; AddItem(ModSliderOption.Create(\"Slider1\", \"My Slider\", 0, 50, 15, 25)); AddItem(ModToggleOption.Create(\"Toggle1\", \"My Toggle\", true)); AddItem(ModToggleOption.Create(\"Toggle2\", \"My Other Toggle\", true)); } private void Options_Changed(object sender, OptionEventArgs e) { switch (e) { case SliderChangedEventArgs sliderArgs: switch (sliderArgs.Id) { case \"Slider1\": /// Handle changes here break; } break; case ToggleChangedEventArgs toggleArgs: switch (toggleArgs.Id) { case \"Toggle1\": /// Handle changes here break; case \"Toggle2\": /// Handle changes here break; } break; } } }"
  },
  "tutorials/overview.html": {
    "href": "tutorials/overview.html",
    "title": "Tutorials",
    "summary": "Tutorials This section covers step-by-step tutorials on how to get some of the useful features of Nautilus done with images, demos, and working code. If you've used SML 2.0 before, please start with our Updating to Nautilus Guide. Sections Adding Content Spawning objects in the world Custom console commands Story goals Databank entries Custom vehicle upgrade modules Custom biomes FMOD and Custom Audio Custom title screens Custom loading screens Prefabs Prefab basics Loading & instantiating prefabs Editing Content Background type Equipment type Crafting recipes Utilities Localization In-Game options Mod loading during loading screen Quick References Customizing your C# project Craft tree paths"
  },
  "tutorials/prefabs-overview.html": {
    "href": "tutorials/prefabs-overview.html",
    "title": "Prefab Basics",
    "summary": "Prefab Basics Creating and utilizing prefabs is essential for any Subnautica mod that adds new content. This page will provide basic information on how prefabs are used in Subnautica and why they are important. What are prefabs? At the most basic levels, prefabs are simply GameObjects that are instantiated into a scene. This is a Unity Engine concept, and it applies for Subnautica modding as well. In Subnautica, prefabs are essentially anything that exists in the world outside of terrain and the player, with a few other exceptions. This encompasses anything from creatures to base modules to unnamed rock formations and debris props. They are registered and managed by the UWE.PrefabDatabase class. Nautilus allows you to indirectly register your own custom prefabs into this system. Subnautica prefabs consist of the following: Class ID (defined in the GameObject's PrefabIdentifier component) TechType (this is actually optional, and is defined in the GameObject's TechTag component) The actual GameObject that is spawned. Differences between Class ID and TechType These are two distinct identification systems used by the game and should not be confused. The Class ID is the only thing that is required for a prefab. A mod that adds new commands such as DebugHelper is required to actually spawn a prefab by its Class ID. Generally, Class IDs are 36 character strings, but when you create a prefab with Nautilus the Class ID will actually match its TechType. You can find a list of all Class IDs here. TechTypes are more accessible and readable. You may recognize them from the spawn command. Unlike Class IDs, which live in an obfuscated file, TechTypes are all listed under the TechType enum in the game's code. There are potentially thousands of prefabs that cannot be spawned with the spawn command because they don't have a TechType assigned. These are also required for crafting, blueprints and inventory items. The most important part? There can be multiple prefabs with the same TechType, but every prefab has a different Class ID. This is why you can have multiple fragments with different models that unlock the same blueprint. Essential components There are a few components that are required or heavily recommended for prefabs. The PrefabUtils.AddBasicComponents method provided by Nautilus handles most of this for you, besides Pickupable. PrefabIdentifier: The only one that is truly required for something to be spawned. Holds the Class ID of your prefab so it can be saved and loaded. TechTag: Holds the TechType of your prefab. This is not required for prefabs, but is needed for many cases. It's nice because it lets you use the spawn command. LargeWorldEntity: Heavily recommended. Generally needed for a prefab to save properly. You also will want to set its cellLevel field to change its loading distance. SkyApplier: Required for proper shading whenever you have a custom model. Pickupable: Not required unless you are making an inventory item."
  },
  "tutorials/spawns.html": {
    "href": "tutorials/spawns.html",
    "title": "Adding Spawns",
    "summary": "Adding Spawns Most of the time in Subnautica, the game uses two main approaches to spawning objects: 1) static spawns that always spawn in the world at a fixed position, and 2) runtime loot distribution which is biome-based and pseudo-random. Nautilus offers utilities that allow modders to add spawns to either system. You can add spawns for your own custom items, edit vanilla spawns, and remove existing random spawns. There also exist tools such as the Mod Structure Helper, designed for placing many static spawns with a visual editor. Coordinated Spawns The Coordinated Spawns system is Nautilus' implementation of the aforementioned static spawns. With this system, you are allowed to specify exact world positions, rotations and scales for item spawns. You may register one or more coordinated spawn(s) for any item by providing either its class ID or tech type. Examples The following examples demonstrate the usage of CoordinatedSpawnsHandler methods. private void Awake() { // Adds a Reaper Leviathan to the lava lakes SpawnInfo reaperInfo = new SpawnInfo(TechType.ReaperLeviathan, new Vector3(280f, -1400f, 47f)); // Lava Lakes CoordinatedSpawnsHandler.RegisterCoordinatedSpawn(reaperInfo); // Adds multiple spawn infos at once // Sand Shark's class ID string sandSharkId = \"5e5f00b4-1531-45c0-8aca-84cbd3b580a4\"; var spawnInfos = new List<SpawnInfo>() { new SpawnInfo(TechType.Seamoth, Vector3.zero), new SpawnInfo(sandSharkId, new Vector3(10, -4, 5), Vector3.up * 90f) // rotate its Y axis 90 degrees } CoordinatedSpawnsHandler.RegisterCoordinatedSpawns(spawnInfos); // Spawns a batch of titaniums around 10, -3, 15 world position var randomPositions = RandomPositions(new Vector3(10f, -3f, 15f)); CoordinatedSpawnsHandler.RegisterCoordinatedSpawnsForOneTechType( TechType.Titanium, randomPositions); } private List<Vector3> RandomPositions(Vector3 centerPosition) { var result = new List<Vector3>(); for (int i = 0; i < 5; i++) { result.Add(centerPosition + (Random.insideUnitSphere * i)); } return result; } For custom prefabs, it is advised to use the ICustomPrefab.SetSpawns(SpawnLocation[]) method instead of directly interacting with the CoordinatedSpawnsHandler class. The example below demonstrates the usage of the SetSpawns method. var blueReaper = new CustomPrefab(\"BlueReaper\", \"Blue Reaper Leviathan\", null); // Creates a clone of the Reaper Leviathan prefab and colors it blue, then set the new prefab as our Blue Reaper's game object. var blueReaperPrefab = new CloneTemplate(blueReaper.Info, TechType.ReaperLeviathan) { ModifyPrefab = prefab => prefab.GetComponentsInChildren<Renderer>().ForEach(r => r.materials.ForEach(m => m.color = Color.blue)) }; blueReaper.SetGameObject(blueReaperPrefab); // Adds a spawn for our Blue Reaper Leviathan in the lava lakes. blueReaper.SetSpawns(new SpawnLocation(280f, -1400, 47f)); // Register the Blue Reaper Leviathan to the game. blueReaper.Register(); Loot Distribution The loot distribution system is by far the most widely used spawning system in the game for collectible items. Unlike static spawns, Nautilus does not have its own version of this system, so we will be registering distributions directly into the game's existing system (which affects existing spawn slots). Loot distribution only allows adding or editing distributions using a class ID and prefab file name. You normally will also need to provide a biome type, probability, and count for each loot you want to add. Below is a table of all the parameters you may interact with in the loot distribution system. Parameter Name Type Description classId string The classId of the entity to add loot for. prefabFileName string The internal file path of the entity to add. biomeDistribution LootDistributionData.BiomeData The biome data in which this entity might spawn in. probability float The chance of this entity spawning. This value can only be between 0-1 inclusive. 0 being no chance of spawning, while 1 is guaranteed to spawn. count float Multiplies 1 with this value. This multiplication is accounted everytime this entity has the highest chance to spawn, not a global count. srcData LootDistributionData.SrcData A class that combines the prefab file name and biome distribution to one data type. entityInfo WorldEntityInfo Contains information on how to spawn this entity. E.G: The size it should spawn in as, and how far it can stay before unloading. Warning An Entity Info for each class ID to spawn via loot distribution is required. If an entity info does not have one, the loot distribution will ignore it. Also, most spawn slots in the game only spawn entities with Small or Medium entity slot types. Note Usually, vanilla prefabs do have a world entity info assigned to them. While you can, you don't have to register a new one for those that already have one. Examples The following examples demonstrate the usage of LootDistributionHandler methods. // Drillable Sulphur's class ID string drillableSulphurClassId = \"697beac5-e39a-4809-854d-9163da9f997e\"; var biomes = new LootDistribution.BiomeData[] { // Lost river's bones field ground new LootDistributionData.BiomeData { biome = BiomeType.BonesField_Ground, count = 1, probability = 0.07f }, // Inactive Lava Zone floor, near the lava new LootDistributionData.BiomeData { biome = BiomeType.InactiveLavaZone_Chamber_Floor_Far, count = 1, probability = 0.05f } }; // Add spawn for the drillable sulphur LootDistributionHandler.AddLootDistributionData(drillableSulphurClassId, biomes); string rockgrubClassId = CraftData.GetClassIdForTechType(TechType.Rockgrub); // Prevents the rockgrub from spawning in the Bulb zone caves. LootDistributionHandler.EditLootDistributionData(rockgrubClassId, BiomeType.KooshZone_CaveWall, 0f, 0); For custom prefabs, it is advised to use the ICustomPrefab.SetSpawns(LootDistributionData.BiomeData[]) method instead of directly interacting with the LootDistributionHandler class. The example below demonstrates the usage of the SetSpawns method. // Set the vanilla titanium icon for our item CustomPrefab titaniumClone = new CustomPrefab(\"TitaniumClone\", \"Titanium Clone\", \"Titanium clone that makes me go yes.\", SpriteManager.Get(TechType.Titanium)); // Creates a clone of the Titanium prefab and colors it red, then set the new prefab as our Titanium Clone's game object. PrefabTemplate cloneTemplate = new CloneTemplate(titaniumClone.Info, TechType.Titanium) { // Callback to change all material colors of this clone to red. ModifyPrefab = prefab => prefab.GetComponentsInChildren<Renderer>().ForEach(r => r.materials.ForEach(m => m.color = Color.red)) }; titaniumClone.SetGameObject(cloneTemplate); titaniumClone.SetSpawns( // Adds a chance for our titanium clone to spawn in Safe shallows grass, x4 each time. new BiomeData { biome = BiomeType.SafeShallows_Grass, count = 4, probability = 0.1f }, // Adds a chance for our titanium clone to spawn in Safe shallows caves, once each time. new BiomeData { biome = BiomeType.SafeShallows_CaveFloor, count = 1, probability = 0.4f }); // Register the Titanium Clone to the game. titaniumClone.Register(); See also CoordinatedSpawnsHandler LootDistributionHandler"
  },
  "tutorials/story-goals.html": {
    "href": "tutorials/story-goals.html",
    "title": "Using the Story Goal system",
    "summary": "Using the Story Goal system The progression of Subnautica is primarily based around the Story Goal system. This system is composed of the StoryGoalManager class and several sub-systems which together handle hundreds of different goals, each with their own unique triggers and effects on completion. Nautilus provides a new handler for accessing this system, which was not available in SMLHelper. This guide covers the basics of how to use them, and how they may help you implement certain features into your mod. Vanilla use-cases Alien data terminals Data consoles in Alterra Wrecks Most story events & progression The PDA databank tab The PDA log tab (any sort of voice lines that play during progression!) The radio, which is an extension of the log system. Possible actions on completion Adding items to the player's inventory Adding PDA databank entries Adding pending radio messages. Playing voice lines through the PDA log system Triggering custom events (this in particular means that a goal can do ANYTHING on completion!) Unlocking achievements Unlocking blueprints Unlocking signal locations The StoryGoal class The StoryGoal object is the basis of all StoryGoals. Every Story Goal has a key, delay, and GoalType. It can also have associated data for what happens on completion, which must be defined in another class. An example of this is the OnGoalUnlockTracker (see StoryGoalHandler.RegisterOnGoalUnlockData). Many sub-classes and trackers exist to automate the unlocking process, as shown in the next section. Note A StoryGoal object can be instantiated directly, without accessing the StoryGoalHandler or any goal tracking classes. However, a goal created in this way must be triggered manually through its Trigger() method. Trackers These internal game classes manage the automatic unlocking of specific goals. You do not need to access them directly, but they are listed below to allow a deeper understanding of how this system works: Tracker type Description ItemGoalTracker Completes a goal (or multiple) when an object with the given TechType is picked up, equipped, or crafted through the Mobile Vehicle Bay. BiomeGoalTracker Completes a goal when the player stays in a given biome for a specified period of time. LocationGoalTracker Completes a goal when the player stays within range of a certain position for a specified period of time. CompoundGoalTracker Completes a goal when all required \"precondition\" goals have been completed. See the creating goals section for a list of methods that allow access to these systems. GoalType Every Story Goal has an assigned Goal Type which determines the action that is executed on completion (if any): GoalType Purpose GoalType.Story Generic GoalType with no default effects. Primarily used for tracking story progress and triggering custom events. GoalType.Encyclopedia Adds a PDA databank entry on completion with the corresponding key. Also see PDAHandler.AddEncyclopediaEntry(...). GoalType.PDA Adds a PDA Log message with the corresponding key. Also see PDAHandler.AddLogEntry(...). GoalType.Radio Adds a pending radio message with the corresponding key. Also see PDAHandler.AddLogEntry(...). StoryGoalHandler This is the main class for interacting with the game's Story Goal system. It allows you to add goals to specific trackers and gives you full control over their actions on completion. Warning As of now, the StoryGoalHandler class has only been tested for the first Subnautica game. If you notice any issues with Below Zero, remember you can always contribute. A more comprehensive overview of the class can be viewed here. Creating goals There are various ways to create Story Goals, and different methods are recommended for different purposes. Remember Story Goals do nothing on their own, and you should also see the section on actions on completion to use them to their full potential. Method Notes new StoryGoal(string key, GoalType goalType, float delay) Creates a new StoryGoal that must be completed manually (through the Trigger() method). RegisterItemGoal(...) Adds a new goal to the ItemGoalTracker system. This goal is completed when an object with the given TechType is picked up, equipped, or crafted through the Mobile Vehicle Bay. RegisterBiomeGoal(...) Adds a new goal to the BiomeGoalTracker system. This goal is completed when the player stays in a given biome for a specified period of time. RegisterLocationGoal(...) Adds a new goal to the LocationGoalTracker system. This goal is completed when the player stays within range of a certain position for a specified period of time. RegisterCompoundGoal(...) Adds a new goal to the CompoundGoalTracker system. This goal is completed when all other specified \"prerequisite\" goals are completed. Completing goals Story goals can be completed in various ways, some more useful than others: Method Notes Automatically, through the tracker systems (handled by the StoryGoalHandler). This is the easiest way to add story goals and is recommended for typical use cases. No extra code is required; this is handled by the StoryGoalHandler methods. StoryGoal.Trigger() (instance) This is the recommended method for manually unlocking goals without a tracker. When called, schedules the goal for completion (based on the delay), then executes all associated actions. StoryGoalManager.main.OnGoalComplete(string key) Returns false if the goal has already been completed. Otherwise, returns true and adds the goal instantly. Has no delay and does not apply the actions defined by the goal's GoalType. StoryGoal.Execute(string key, GoalType goalType) (static) Instantly completes a goal by calling OnGoalComplete, without applying the delay. Properly applies the actions defined by the goal's GoalType. Note The most proper way to complete a Story Goal is through calling the StoryGoal.Trigger() method on a given instance. This specifically applies for goals created through the new StoryGoal(...) constructor rather than through any aforementioned methods. This is the only way to ensure the delay is applied properly and all actions are executed. Actions on completion Within the StoryGoalHandler class, the action(s) on completion can be defined in a couple ways: Method Notes StoryGoalHandler.RegisterCustomEvent(string key, Action customEventCallback) Allows code of any length to be run when the goal is completed. StoryGoalHandler.RegisterOnGoalUnlockData(...) Allows the user to define any blueprints, items, signals or achievements that are gained on completion. Example Example code for registering a Story Goal is shown below. This goal will be triggered after staying in the Kelp Forest for 30 seconds or more. On completion it plays a voice line, kills the player, and unlocks the Seamoth blueprint. using Story; // ... // Register the goal to the BiomeGoalTracker. A GoalType of PDA means that this goal will trigger a PDA line and add it to the log on completion: StoryGoalHandler.RegisterBiomeGoal(\"KelpForestEnjoyer\", GoalType.PDA, biomeName: \"kelpForest\", minStayDuration: 30f, delay: 3f); // Register the PDA voice line. Note how the key matches the key of the story goal: PDAHandler.AddLogEntry(\"KelpForestEnjoyer\", \"KelpForestEnjoyer\", sound); // Set the English translation for PDA message's subtitles: LanguageHandler.SetLanguageLine(\"KelpForestEnjoyer\", \"Congratulations for staying in the Kelp Forest for 30 seconds!\", \"English\"); // Add a custom event that kills the player when this goal is completed: StoryGoalHandler.RegisterCustomEvent(\"KelpForestEnjoyer\", () => { Player.main.liveMixin.TakeDamage(10000f); }); // Unlock the seamoth on completion of this goal: StoryGoalHandler.RegisterOnGoalUnlockData(\"KelpForestEnjoyer\", blueprints: new Story.UnlockBlueprintData[] { new Story.UnlockBlueprintData() {techType = TechType.Seamoth, unlockType = Story.UnlockBlueprintData.UnlockType.Available}, }); Saving progress Every story goal can only be completed once, so no custom saving logic is required. The StoryGoalManager.main.OnGoalComplete(string key) method can be used for one-time events (WITHOUT story goals!) because it will only return true once for any given string, which persists between game sessions. The StoryGoalManager.main.IsGoalComplete(string key) method can be used to check if a goal with the given key has already been completed. Summary The Story Goal system is a powerful tool for creating story and exploration-driven progression in Subnautica mods. By using the methods within the StoryGoalHandler class, you can easily add goals and customize their effects upon completion."
  },
  "tutorials/title-addons.html": {
    "href": "tutorials/title-addons.html",
    "title": "Adding a Custom Title Screen",
    "summary": "Adding a Custom Title Screen Nautilus provides a way for mods to add their own title screen additions without interfering with those from other mods. Understanding Addons Nautilus uses a modular system for title screen additions, allowing for a near endless amount of customizability. The foundation of these additions is the TitleAddon. This class is inherited from by many other addons and provides basic functionality, should you wish to create your own custom addon. How the Title System Works Nautilus's title screen management is accessed primarily through the TitleScreenHandler class. It contains methods to register TitleAddons, as well as for registering mod collabs, which we'll go into later. The TitleScreenHandler contains a subclass called CustomTitleData, which is used to register TitleAddons to Nautilus. It takes in a localization key for the name of your mod, which will be shown in the theme selector, and your title addons. Once you have your title data, you can register it with Nautilus by calling TitleScreenHandler.RegisterTitleScreenObject. This method takes in a key for your data, so that if you create multiple Nautilus knows how to differentiate between the two. Note This tutorial will refer to registered CustomTitleDatas as \"themes\". For example, if a mod registered a custom object and some music, that would be considered the mod's theme. Adding an Object To add an object to the title screen, you will need to use the WorldObjectTitleAddon class. Create a new instance of this class, and you will see that it takes in a Func<GameObject>. This Func is used to spawn your object when you enter the main menu. The reason it is a Func and not a GameObject that you can pass in is so that Nautilus can handle spawning it back in when you exit to the main menu from a save. The recommended way to do this is to create a local function or anonymous function and then pass that into the constructor. An example of this is shown below. GameObject SpawnObject() { var obj = GameObject.CreatePrimitive(PrimitiveType.Cube); obj.transform.position = new Vector3(-27, 2.5f, 38); obj.transform.rotation = Quaternion.Euler(270, 325.7f, 0); obj.AddComponent<SkyApplier>(); MaterialUtils.ApplySNShaders(obj); return obj; } var objectAddon = new WorldObjectTitleAddon(SpawnObject); Warning For proper shading and fade transitions, your object must have a SkyApplier component and Subnautica materials applied. This code will place a default cube to the left of the Subnautica logo once registered with Nautilus. You may have also noticed the optional parameters: fadeInTime and requiredGUIDs. The requiredGUIDs will be discussed later, but the fadeInTime controls how long the fade in duration is for your registered object. Nautilus automatically fades in objects using Subnautica's Renderer.fadeAmount when switching between themes, and this variable controls how long the transition is. By default, it is set to one second. Adding Music Similarly to adding a custom object, you will need to use the MusicTitleAddon to register custom music with Nautilus. If you have Thunderkit and automatic sound registration, this becomes extremely simple, although it requires more set up. Here are various examples of how to create a music addon: Manual Load (From Asset Bundle) Manual Load (From mod folder) Thunderkit private MusicTitleAddon GetMusicAddon() { // Creates a sound using the standard modes for a \"streamed\" sound, loading the audio clip by name from the Asset Bundle var sound = AudioUtils.CreateSound(MyAssetBundle.LoadAsset<AudioClip>(audioClipName), AudioUtils.StandardSoundModes_Stream); // Register the sound under the Music bus CustomSoundHandler.RegisterCustomSound(soundId, sound, AudioUtils.BusPaths.Music); return new MusicTitleAddon(AudioUtils.GetFmodAsset(soundId)); } private MusicTitleAddon GetMusicAddon() { // Creates a sound using the standard modes for a \"streamed\" sound, loading the audio at the given file path var sound = AudioUtils.CreateSound(soundFilePath, AudioUtils.StandardSoundModes_Stream); // Register the sound under the Music bus CustomSoundHandler.RegisterCustomSound(soundId, sound, AudioUtils.BusPaths.Music); return new MusicTitleAddon(AudioUtils.GetFmodAsset(soundId)); } private MusicTitleAddon GetMusicAddon() { return new MusicTitleAddon(MyAssetBundle.LoadAsset<FMODAsset>(\"MyMusic\")); } Changing the Sky To change the sky, including the time of day, exposure, fog, etc., you will need to create a SkyChangeTitleAddon. This addon can be used to achieve an effect identical to the Return of the Ancients demo title screen, which is set to night. The main parameters are the fadeInDuration, and settings (of type Settings, a subclass of SkyChangeTitleAddon). The fade duration determines how long the game should take to transition from the default sky to your custom sky. The settings, however, are slightly more complicated. The parameters are fully explained on the API documentation, but here is a quick rundown of them: timeOfDay: The time of day of the in game sky. Similar to a 24-hour Earth time. exposure: The exposure (brightness) of the sky. rayleighScattering: The strength of light scattering in the sky. Will affect how blue the sky looks and what the atmosphere looks like when the sun is at grazing angles. fogDensity: The density of the fog. All of these have default values set to that of the vanilla sky, but you can mess around with these to find settings that look good to you. For example, this code creates a SkyChangeTitleAddon with a transition time of 2 seconds that sets the time to in-game midnight and increases fog. var skyChangeAddon = new SkyChangeTitleAddon(2f, new SkyChangeTitleAddon.Settings(0f, fogDensity: 0.001f)); Registering Your Addons To register your title addons, you will need to create a TitleScreenHandler.CustomTitleData to hold the data. This class also takes in a localization key for the name of your mod, which will be displayed in the theme selector. Note See the localization tutorial for information on how to create localization lines. After entering your mod name localization key, you can add the rest of your title addons, like so. var customData = new TitleScreenHandler.CustomTitleData(\"MyModLocalizationKey\", objectAddon, musicAddon, skyChangeAddon); After creating your custom data, you will need to register it with Nautilus by calling TitleScreenHandler.RegisterTitleScreenObject. This method takes in a key for your custom title data, so that if you add multiple custom title datas Nautilus knows how to keep track of which is active. The key needs to be unique within the data added by your mod. Here is an example of how to register your data: TitleScreenHandler.RegisterTitleScreenObject(\"MyEpicTitleData\", customData); Now that you have registered your data, a selector will pop up in the bottom left of the screen when in Subnautica's main menu. You can use the arrows to switch between the default title screen and your custom one, and, if you have other mods installed that add custom title screens, those too. Title Collaborations As you may have already noticed, all TitleAddons have an optional parameter for requiredGUIDs. This is so if two mods want to create a collaboration title screen, one mod can create the addons and have the other mod required to be installed for them to show up. To make a mod required for an addon, simply add its GUID to the required GUID parameters. A mod's GUID is the string you place in the [BepInPlugin()] attribute in your plugin class. To find another mod's GUID, you can open up their mod DLL in dnSpy or some other DLL viewing program, and navigate to their plugin to find the BepInPlugin attribute. You can then copy their GUID from there. If you were to try this however, you might find that your addons do not show up even when the required mod is installed. This is because mods that are required by TitleAddons need to approve addons from other mods. This can be done by calling TitleScreenHandler.ApproveTitleCollaboration with your mod's CollaborationData. CollaborationData has multiple constructors, depending on how strict you want to be approving mods. You can either approve all types of TitleAddons using the constructor that only takes in GUIDs, or you can be more specific and whitelist only certain types by using the constructor with a GUID/Type array dictionary. Examples: // Approve all collaborations from the map mod. The \"this\" keyword is the instance of your plugin. // This method assumes that it is being called from your plugin. TitleScreenHandler.ApproveTitleCollaboration(this, new TitleScreenHandler.CollaborationData(new string[] { \"sn.subnauticamap.mod\" } )) // Only approves collabs from the map mod that are WorldObjectTitleAddons TitleScreenHandler.ApproveTitleCollaboration(this, new TitleScreenHandler.CollaborationData(new () { { \"sn.subnauticamap.mod\", new Type[] { typeof(WorldObjectTitleAddon) } } } )); Extending the Given Addons If you find that the base TitleAddons are not suited for your specific title requirements, you can make a new class that inherits from TitleAddon to create your own behavior. These classes can be registered. This simple addon logs a message to the in-game ErrorMessage class when the addon is enabled and disabled. using Nautilus.Handlers.TitleScreen; public class MyCoolAddon : TitleAddon { // Pass the required GUIDs for collaborations to the TitleAddon base public MyCoolAddon(params string[] requiredGUIDs) : base(requiredGUIDs) { } protected override void OnEnable() { ErrorMessage.AddError(\"MyCoolAddon enabled!\"); } protected override void OnDisable() { ErrorMessage.AddError(\"MyCoolAddon disabled!\"); } } There are also additional methods that can be overridden if additional behavior is required. Here are the two others that can be extended: OnInitialize(): Called once when all the addons are loaded in. Can be used for one time setups, such as in the WorldObjectTitleAddon where it is used to spawn the object passed in. OnEnterLoadScreen(): Called when the player starts loading a save. Can be used to cleanup persistent changes, such as in the SkyChangeTitleAddon."
  },
  "tutorials/vehicle-module.html": {
    "href": "tutorials/vehicle-module.html",
    "title": "Using the Vehicle Upgrade Module Gadget",
    "summary": "Using the Vehicle Upgrade Module Gadget Vehicle modules are often hard to mod, and when multiple mods patch a function of a vehicle there can be severe conflicts that could break all the mods adding new modules. The Vehicle Upgrade Module Gadget was made to make your life of modder as easy as possible when it comes to vehicle modules. This brand new gadget was made to be compatible with both Below Zero and Subnautica 1, some functions differ between Nautilus for SN1 and Nautilus for BZ. Possibilities of custom vehicle upgrade modules Set the new crush depth of the vehicle when the upgrade is equipped. You can choose whether the depth is absolute or added to the default crush depth of the vehicle. Set the max charge of the module if the module slot type is set to QuickSlotType.SelectableChargeable or QuickSlotType.Chargeable. The way to measure the charge is still blurry. Set the energy cost of the module if the module slot type is set to QuickSlotType.Selectable, QuickSlotType.Instant, QuickSlotType.SelectableChargeable or QuickSlotType.Chargeable. Charge does not affect the energy consumption. Set the cooldown of the module if the module slot type is set to QuickSlotType.Selectable, QuickSlotType.Instant, QuickSlotType.SelectableChargeable or QuickSlotType.Chargeable. Charge does not affect the cooldown. The unit of the cooldown is seconds, and stored as a double on Subnautica 1 and as a float on Below Zero. Add delegates when some actions are done, and they all give many parameters so you can make actions on the vehicle. Here are the events supported by Nautilus, and preventing conflicts between mods: When the module is added to the vehicle When the module is removed from the vehicle When the module is used (Any active QuickSlotType triggers this except QuickSlotType.Toggleable) When the module is toggled. One of the parameters given into the delegate is a boolean which is the state of the module. What is the Upgrade Module Gadget The Upgrade Module Gadget is an extension for the ICustomPrefab. It is basically patching many functions of the vehicles using prefix, postfixes and transpilers for a better compatibility and more safety. Basically, all the modules are stored locally by Nautilus in order to run actions, set the modules settings in game, such as the crush depth if provided, the cooldown if provided, etc... Create a module with the gadget Here are some examples of uses of the gadget, used in many ways. You are not limited, you can do everything you want with those. Passive module setting a new crush depth Let's create a custom module setting the depth to, let's say, 1700m for the SeaMoth. So, first, let's make our prefab info. var prefabInfo = PrefabInfo.WithTechType(\"SeamothDepthUpgrade\", \"Seamoth Depth Module MK.4\", \"Dive down to 1700 meters!!! Let's meet the Sea Dragon!\") .WithIcon(SpriteManager.Get(TechType.HullReinforcementModule3)); CustomPrefab prefab = new CustomPrefab(prefabInfo); Then, we're making the Custom Prefab based on Reinforced Hull prefab. var clone = new CloneTemplate(prefabInfo, TechType.HullReinforcementModule3); prefab.SetGameObject(clone); Now, let's quickly set the basic settings. prefab.SetRecipe(new Crafting.RecipeData() { craftAmount = 1, Ingredients = new List<CraftData.Ingredient>() { new CraftData.Ingredient(TechType.HullReinforcementModule3), new CraftData.Ingredient(TechType.AluminumOxyde, 2), new CraftData.Ingredient(TechType.AdvancedWiringKit, 3) } }) .WithFabricatorType(CraftTree.Type.SeamothUpgrades) .WithStepsToFabricator(\"SeamothModules\") .WithCraftingTime(5f); And finally, let's make the part that interest us: Adding the Upgrade Module Gadget. // This first function defines the equipment type and the quick slot type. prefab.SetVehicleUpgradeModule(EquipmentType.SeamothModule, QuickSlotType.Passive) .WithDepthUpgrade(1700f, true) // 1700 is the depth in meters. The boolean after defines if we want the value to be absolute or \"relative\", added to the default depth. // If it is on false, it will set the new crush depth to 1900 meters because the default depth of the Seamoth is 200 meters. // Otherwise, it will set the new crush depth on 1700 meters. .WithOnModuleAdded((Vehicle vehicleInstance, int slotId) => { Subtitles.Add(\"Well done! The module is working! The new depth is 1700 meters.\"); }) .WithOnModuleRemoved((Vehicle vehicleInstance, int slotId) => { Subtitles.Add(\"Ah... You removed the upgrade. Take care of your hull.\"); }); Note You can do basically everything you want in these delegates, such as trigger story events, destroy the vehicle, add components to the vehicle instance, etc... Chargeable self-destruct module Admitting we've already done the prefab info and the custom prefab, let's directly work only with the upgrade module gadget. var maxCharge = 50f; var cooldown = 10f; var energyCost = 6.9f; prefab.SetVehicleUpgradeModule(EquipmentType.VehicleModule, QuickSlotType.SelectableChargeable) .WithMaxCharge(maxCharge) .WithCooldown(cooldown) .WithEnergyCost(energyCost) .WithOnModuleAdded((Vehicle inst, int slotId) => { Subtitles.Add(\"Self-destruct module installed. The module needs to be charged fully to detonate.\"); }) .WithOnModuleRemoved((Vehicle inst, int slotId) => { Subtitles.Add(\"Self-destruct module uninstalled.\"); }) .WithOnModuleUsed((Vehicle inst, int slotID, float charge, float chargeScalar) => { if (charge < maxCharge) { Subtitles.Add(\"Self-destruction sequence disengaged.\") return; } else { Subtitles.Add(\"Self-destruction sequence engaged.\") UWE.CoroutineHost.StartCoroutine(EngageSelfDestruct(inst, countdown)); } }); static IEnumerator EngageSelfDestruct(Vehicle instance, float countdown) { var startTime = Time.time while(Time.time < (startTime + countdown)) { yield return null; } instance.liveMixin.Kill(DamageType.Explosive); } Instant selectable message sender Yet another example... prefab.SetVehicleUpgradeModule(EquipmentType.VehicleModule, QuickSlotType.Selectable) .WithOnModuleUsed((Vehicle inst, int slotID, float _charge, float _chargeScalar) => // charge and chargeScalar are always 0f here. { Subtitles.Add(\"Hello world!\"); }); And you can do a lot more."
  }
}